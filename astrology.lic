# frozen_string_literal: true

=begin
  Documentation: https://elanthipedia.play.net/Lich_script_repository#astrology
=end

class Astrology
  # Pool understanding level patterns for predict state parsing.
  POOL_PATTERNS = {
    /You have no understanding of the celestial influences over/            => 0,
    /You have a feeble understanding of the celestial influences over/      => 1,
    /You have a weak understanding of the celestial influences over/        => 2,
    /You have a fledgling understanding of the celestial influences over/   => 3,
    /You have a modest understanding of the celestial influences over/      => 4,
    /You have a decent understanding of the celestial influences over/      => 5,
    /You have a significant understanding of the celestial influences over/ => 6,
    /You have a potent understanding of the celestial influences over/      => 7,
    /You have an insightful understanding of the celestial influences over/ => 8,
    /You have a powerful understanding of the celestial influences over/    => 9,
    /You have a complete understanding of the celestial influences over/    => 10
  }.freeze

  # Start pattern for predict state all output capture.
  PREDICT_STATE_START = /celestial influences/.freeze

  # End pattern for predict state all output capture.
  PREDICT_STATE_END = /Roundtime/i.freeze

  # Patterns indicating observation completed (success or acceptable completion).
  # Used by observe_routine for non-telescope observation to determine if done.
  # Note: Roundtime removed - DRCMM.observe no longer returns it (more specific patterns match first).
  OBSERVE_SUCCESS_PATTERNS = [
    'While the sighting',           # Partial success
    'You learned something useful', # Full success
    'Clouds obscure',               # Weather blocking (observation done)
    'You learn nothing',            # Circle too low (observation done)
    'too close to the sun',         # Solar conjunction (observation done)
    'too faint for you',            # Telescope needed (observation done)
    'below the horizon',            # Body not visible (observation done)
    'You have not pondered',        # Observation cooldown (done, no XP)
    'You are unable to make use'    # Cooldown followup (done, no XP)
  ].freeze

  # Perceive targets for attunement training.
  PERCEIVE_TARGETS = ['', 'mana', 'moons', 'planets', 'psychic', 'transduction', 'perception', 'moonlight'].freeze

  def initialize
    unless DRStats.moon_mage?
      Lich::Messaging.msg('bold', 'Astrology: This script is only for Moon Mages. Exiting.')
      exit
    end

    @settings = get_settings
    arg_definitions = [
      [],
      [{ name: 'rtr', regex: /rtr/i, description: 'Runs Read the Ripples' }]
    ]
    args = parse_args(arg_definitions)

    # Make sure that our Circle is up-to-date - avoid using stale data for new characters who joined the guild
    DRC.bput('info', 'Circle:') if DRStats.circle.zero?

    @equipment_manager = EquipmentManager.new
    @constellations = get_data('constellations').constellations
    @finished_messages = get_data('constellations').observe_finished_messages
    @success_messages = get_data('constellations').observe_success_messages
    @injured_messages = get_data('constellations').observe_injured_messages
    @force_visions = @settings.astrology_force_visions
    @divination_tool = @settings.divination_tool
    @divination_bones_storage = @settings.divination_bones_storage
    @have_telescope = @settings.have_telescope
    @telescope_storage = @settings.telescope_storage
    @telescope_name = @settings.telescope_name
    @astral_place_source = @settings.astral_plane_training['train_source']
    @astral_plane_destination = @settings.astral_plane_training['train_destination']
    @prediction_pool_target = @settings.astrology_use_full_pools ? 10 : @settings.astrology_pool_target
    @rtr_data = nil
    @astrology_prediction_skills_magic = @settings.astrology_prediction_skills['magic']
    @astrology_prediction_skills_lore = @settings.astrology_prediction_skills['lore']
    @astrology_prediction_skills_offense = @settings.astrology_prediction_skills['offense']
    @astrology_prediction_skills_defense = @settings.astrology_prediction_skills['defense']
    @astrology_prediction_skills_survival = @settings.astrology_prediction_skills['survival']
    Lich::Messaging.msg('plain', "Astrology: Flags['rtr-expire'].nil? #{Flags['rtr-expire'].nil?}") if UserVars.astrology_debug
    Lich::Messaging.msg('plain', "Astrology: Flags['rtr-expire'] = #{Flags['rtr-expire']}") if UserVars.astrology_debug

    do_buffs(@settings)

    if args.rtr
      check_ripples(@settings)
    else
      train_astrology(@settings)
    end
  end

  def do_buffs(settings)
    return unless settings
    return unless settings.waggle_sets['astrology']

    empty_hands
    buffs = settings.waggle_sets['astrology']
    @rtr_data = buffs.select { |spell| spell.eql?('Read the Ripples') }
                     .values
                     .first
    buffs.reject! { |spell| spell.eql?('Read the Ripples') }

    # Check if all buffs are already active
    all_buffs_active = buffs.all? do |_, value|
      value['use_auto_mana'] && DRSpells.active_spells.include?(value['name'])
    end

    if all_buffs_active
      Lich::Messaging.msg('plain', 'Astrology: All buffs are already active.') if UserVars.astrology_debug
      return
    end

    buffs.each_value do |value|
      next unless value['use_auto_mana']

      DRCA.check_discern(value, settings)
    end

    buffs.reject! { |_, value| DRSpells.active_spells.include?(value['name']) }

    DRCA.cast_spells(buffs, settings) unless buffs.empty?
  end

  def visible_bodies
    result = []
    all_bodies = @constellations
    case DRCMM.observe('heavens')
    when "That's a bit hard to do while inside"
      Lich::Messaging.msg('bold', 'Astrology: Must be outdoors to observe sky. Exiting.')
      return nil
    end

    until (line = get?) =~ /^Roundtime/i
      result << all_bodies.find { |body| /\b#{body['name'].split.last}\b/i =~ line && line !~ /below the horizon/ }
    end
    result.compact.select { |data| data['circle'] <= DRStats.circle }
  end

  def check_attunement
    return if DRSkill.getxp('Attunement') > 30

    PERCEIVE_TARGETS.each do |target|
      DRC.bput("perceive #{target}", 'roundtime')
      waitrt?
    end
  end

  def check_pools
    pools = {
      'lore'             => 0,
      'magic'            => 0,
      'survival'         => 0,
      'offensive combat' => 0,
      'defensive combat' => 0,
      'future events'    => 0
    }

    # Use issue_command for reliable multi-line capture instead of reget
    # This replaces the old DRCMM.predict('all') + reget(50) pattern
    lines = Lich::Util.issue_command(
      'predict state all',
      PREDICT_STATE_START,
      PREDICT_STATE_END,
      timeout: 10,
      usexml: false,
      silent: true,
      quiet: true
    )

    if lines.nil?
      Lich::Messaging.msg('bold', 'Astrology: Failed to capture predict state output. Using default pool values.')
      waitrt?
      return pools
    end

    lines.select! { |line| line =~ /celestial influences/ }
    pools.each_key do |name|
      matching_line = lines.find { |line| line =~ /#{name}/ }
      next unless matching_line

      POOL_PATTERNS.each do |pattern, value|
        if pattern =~ matching_line
          pools[name] = value
          break
        end
      end
    end

    Lich::Messaging.msg('plain', "Astrology: pools: #{pools}") if UserVars.astrology_debug
    waitrt?
    pools
  end

  def check_events(pools)
    waitrt?
    prev_size = pools['future events']
    start_time = Time.now
    timeout = 10 # Timeout in seconds

    until Time.now - start_time > timeout
      result = DRCMM.study_sky
      waitrt?
      return if result =~ /You are unable to sense additional information|detect any portents/

      new_pools = check_pools
      break if new_pools['future events'] == prev_size
      break if new_pools['future events'] == 10

      prev_size = new_pools['future events']
    end
    DRCMM.predict('event')
  end

  def check_weather
    Lich::Messaging.msg('plain', 'Astrology: Checking the weather.') if UserVars.astrology_debug
    DRCMM.predict('weather')
    waitrt?
  end

  def rtr_active?
    # DRSpells.active_spells sometimes shows RtR as inactive even though it is active
    100.times do
      pause 0.01
      return true if DRSpells.active_spells.include?('Read the Ripples')
    end
    false
  end

  def check_ripples(settings)
    unless @rtr_data
      Lich::Messaging.msg('bold', 'Astrology: No Read the Ripples spell data configured. Skipping ripples check.')
      return
    end
    unless settings
      Lich::Messaging.msg('bold', 'Astrology: No settings provided to check_ripples. Skipping.')
      return
    end
    if !Flags['rtr-expire'].nil? && !Flags['rtr-expire']
      Lich::Messaging.msg('plain', 'Astrology: RtR expire flag indicates spell recently expired. Skipping.') if UserVars.astrology_debug
      return
    end

    empty_hands
    DRCA.cast_spell(@rtr_data, settings)
    perc_time = Time.now - 61
    Flags.add('rtr-expire', get_data('spells').spell_data['Read the Ripples']['expire']) if rtr_active?
    DRCMM.get_telescope?(@telescope_name, @telescope_storage) if @have_telescope
    while rtr_active?
      line = get?
      if perc_time + 60 < Time.now
        DRCA.perc_mana
        perc_time = Time.now
      end
      res = @constellations.find { |body| /As your consciousness drifts amongst the currents of Fate, .* #{body['name']}/i =~ line }
      observe_routine(res['name']) unless res.nil?
    end
    DRCMM.store_telescope?(@telescope_name, @telescope_storage) if @have_telescope
    nil
  end

  def check_astral
    return unless DRStats.circle > 99
    unless @astral_place_source
      Lich::Messaging.msg('plain', 'Astrology: No astral_plane_training train_source configured. Skipping.') if UserVars.astrology_debug
      return
    end
    unless @astral_plane_destination
      Lich::Messaging.msg('plain', 'Astrology: No astral_plane_training train_destination configured. Skipping.') if UserVars.astrology_debug
      return
    end
    if !UserVars.astral_plane_exp_timer.nil? && Time.now - UserVars.astral_plane_exp_timer < 3600
      Lich::Messaging.msg('plain', 'Astrology: Astral plane training on cooldown. Skipping.') if UserVars.astrology_debug
      return
    end

    DRC.wait_for_script_to_complete('bescort', ['ways', @astral_plane_destination])
    UserVars.astral_plane_exp_timer = Time.now
    DRC.wait_for_script_to_complete('bescort', ['ways', @astral_place_source])
    Lich::Messaging.msg('plain', 'Astrology: Completed astral plane training.')
  end

  def empty_hands
    DRCMM.store_telescope?(@telescope_name, @telescope_storage) if DRCI.in_hands?(@telescope_name)
    @equipment_manager.empty_hands
  end

  def predict_all(pools)
    skillset_to_pool = {
      'offensive combat' => @astrology_prediction_skills_offense,
      'defensive combat' => @astrology_prediction_skills_defense,
      'magic'            => @astrology_prediction_skills_magic,
      'survival'         => @astrology_prediction_skills_survival,
      'lore'             => @astrology_prediction_skills_lore,
      'future events'    => 'future events'
    }

    pools.reject { |_skill, size| size < @prediction_pool_target }
         .each_key do |skill|
           break if DRSkill.getxp('Astrology') > 30

           align_routine(skillset_to_pool[skill])
    end
  end

  def check_heavens
    empty_hands
    vis_bodies = visible_bodies
    unless vis_bodies
      Lich::Messaging.msg('bold', 'Astrology: Could not observe visible bodies. Aborting check_heavens.')
      return
    end

    night = vis_bodies.find { |body| body['constellation'] }

    best_eye_data = vis_bodies
                    .select { |data| @have_telescope || !data['telescope'] }
                    .max_by { |data| [data['pools'].values.compact.size, data['circle']] }

    unless best_eye_data
      Lich::Messaging.msg('bold', 'Astrology: No observable celestial bodies found. Aborting check_heavens.')
      return
    end

    Lich::Messaging.msg('plain', "Astrology: best_eye_data = #{best_eye_data}") if UserVars.astrology_debug

    waitrt?

    if @have_telescope
      things_to_try = @constellations.select do |data|
        data['telescope'] &&
          data['circle'] <= DRStats.circle &&
          data['circle'] > best_eye_data['circle'] &&
          (night || !data['constellation']) &&
          data['pools'].values.compact.size > best_eye_data['pools'].values.compact.size
      end

      things_to_try << best_eye_data

      # Fixed: sort_by! instead of sort! with single-argument block
      things_to_try.sort_by! { |data| -data['circle'] }

      Lich::Messaging.msg('plain', "Astrology: things_to_try = #{things_to_try}") if UserVars.astrology_debug

      begin
        things_to_try.find do |data|
          finished = nil
          DRCMM.get_telescope?(@telescope_name, @telescope_storage) if @have_telescope

          until finished
            return check_heavens if Flags['bad-search'] == 'is foiled by the daylight'
            next if Flags['bad-search'] == 'turns up fruitless'

            result = observe_routine(data['name'])
            finished = check_observation_finished?(result)

            Lich::Messaging.msg('plain', "Astrology: result: #{result}") if UserVars.astrology_debug
            Lich::Messaging.msg('plain', "Astrology: finished_messages: #{Regexp.union(@finished_messages)}") if UserVars.astrology_debug
            Lich::Messaging.msg('plain', "Astrology: finished: #{finished}") if UserVars.astrology_debug
          end

          check_observation_success?(result)
        end
      ensure
        DRCMM.store_telescope?(@telescope_name, @telescope_storage) if @have_telescope
      end
    else
      until observe_routine(best_eye_data['name'])
        if Flags['bad-search']
          check_heavens
          return
        end
      end
    end

    pause 2
    waitrt?
  end

  # Check if observation is finished based on result type (handles both old and new Lich versions).
  def check_observation_finished?(result)
    return false unless result

    if result.is_a?(Array)
      result.any? { |line| line.match?(Regexp.union(@finished_messages)) }
    else
      @finished_messages.include?(result)
    end
  end

  # Check if observation was successful based on result type (handles both old and new Lich versions).
  def check_observation_success?(result)
    return false unless result

    if result.is_a?(Array)
      result.any? { |line| @success_messages.any? { |msg| line.include?(msg) } }
    else
      @success_messages.include?(result)
    end
  end

  def get_healed
    DRCMM.store_telescope?(@telescope_name, @telescope_storage) if @have_telescope
    snapshot = Room.current.id
    DRC.wait_for_script_to_complete('safe-room', ['force'])
    DRCT.walk_to(snapshot)
    do_buffs(@settings)
    DRCMM.get_telescope?(@telescope_name, @telescope_storage) if @have_telescope
  end

  def observe_routine(body)
    Flags.add('bad-search', 'is foiled by the (daylight|darkness)', 'turns up fruitless')

    begin
      if @have_telescope
        case DRCMM.center_telescope(body)
        when /Center what/
          DRCMM.get_telescope?(@telescope_name, @telescope_storage)
          return observe_routine(body)
        when /open it/
          DRC.bput('open my telescope', 'extend your telescope')
          return observe_routine(body)
        when /The pain is too much/, /Your vision is too fuzzy/
          get_healed
          return observe_routine(body)
        end
        result = DRCMM.peer_telescope
        injuries, closed = check_telescope_result(result)
        if injuries
          get_healed
          return observe_routine(body)
        elsif closed
          DRC.bput('open my telescope', 'extend your telescope')
          return observe_routine(body)
        end

        result
      else
        observe_result = DRCMM.observe(body)
        OBSERVE_SUCCESS_PATTERNS.any? { |pattern| observe_result&.include?(pattern) }
      end
    ensure
      # Flags cleanup is handled in before_dying, but we reset here for loop iterations
      Flags.reset('bad-search') if Flags['bad-search']
    end
  end

  # Check telescope peer result for injuries or closed telescope.
  def check_telescope_result(result)
    injuries = false
    closed = false

    if result.is_a?(Array)
      injuries = result.any? { |line| line.match?(Regexp.union(@injured_messages)) }
      closed = result.any? { |line| line.start_with?("You'll need to open it") }
    else
      case result
      when /The pain is too much/, /Your vision is too fuzzy/
        injuries = true
      when /open it/
        closed = true
      end
    end

    [injuries, closed]
  end

  def align_routine(skill = nil)
    Lich::Messaging.msg('plain', "Astrology: align_routine called with skill: #{skill.inspect}") if UserVars.astrology_debug
    if skill == 'future events'
      DRCMM.predict('event')
      return
    end
    DRCMM.align(skill)
    waitrt?
    if !@divination_bones_storage.nil? && !@divination_bones_storage.empty? && @force_visions != true
      DRCMM.roll_bones(@divination_bones_storage)
    elsif !@divination_tool.nil? && !@divination_tool.empty? && @force_visions != true
      DRCMM.use_div_tool(@divination_tool)
    else
      DRCMM.predict('future')
    end
    waitrt?
    pause
    pause 0.5 while stunned?
    DRC.fix_standing
  end

  def train_astrology(settings)
    loop do
      unless settings
        Lich::Messaging.msg('bold', 'Astrology: No settings provided. Exiting training loop.')
        return
      end
      unless settings.astrology_training.is_a?(Array)
        Lich::Messaging.msg('bold', 'Astrology: astrology_training is not an array. Exiting training loop.')
        return
      end
      if settings.astrology_training.none?
        Lich::Messaging.msg('bold', 'Astrology: astrology_training is empty. Exiting training loop.')
        return
      end

      settings.astrology_training.each do |task|
        break if DRSkill.getxp('Astrology') >= 32

        case task
        when 'ways'
          check_astral
        when 'observe'
          check_heavens
        when 'rtr'
          check_ripples(settings)
        when 'weather'
          check_weather
        when 'events'
          check_events(check_pools)
        when 'attunement'
          check_attunement
        else
          Lich::Messaging.msg('bold', "Astrology: Unknown training task '#{task}'. Skipping.")
        end
      end

      if DRSkill.getxp('Astrology') >= 32
        Lich::Messaging.msg('plain', 'Astrology: Reached target Astrology XP. Training complete.')
        break
      else
        predict_all(check_pools)
        DRCMM.predict('analyze')
        waitrt?
      end
    end
  end
end

before_dying do
  Flags.delete('bad-search')
  Flags.delete('rtr-expire')
  telescope_storage = get_settings.telescope_storage
  telescope_name = get_settings.telescope_name
  divination_tool = get_settings.divination_tool

  # Use DRCI.in_hands? for nil-safe hand checks
  if DRCI.in_hands?(telescope_name)
    DRCMM.store_telescope?(telescope_name, telescope_storage)
  end

  if divination_tool && divination_tool['name'] && DRCI.in_hands?(divination_tool['name'])
    DRCMM.store_div_tool?(divination_tool)
  end
end

# Call this last to avoid the need for forward declarations
Astrology.new
