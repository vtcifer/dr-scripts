=begin
        Alternative trainer script which kicks off sub-scripts based on
        current mindstates.  See Leustyin-setup and Chuno-setup for examples
        This script uses the `training_list` key to define the skills to train
        and thresholds in which the scripts should be started
=end

custom_require.call(%w[common common-arcana equipmanager])

class T2
  def initialize
    arg_definitions = [
      [
        { name: 'nodelay', regex: /nodelay/i, optional: true, description: 'Skip settings.t2_startup_delay' },
        { name: 'debug',   regex: /^debug$/i, optional: true, description: 'Turn on debug info for t2.'}
      ]
    ]

    @args = parse_args(arg_definitions, true)

    @debug = UserVars.t2_debug || args.debug
    DRC.message("T2 Debugging on") if @debug

    @settings = get_settings(@args.flex)

    @shutdown = false

    fput('awaken') unless @settings.t2_skip_awaken

    @counter = 0
    UserVars.t2_timers ||= {}
    DRC.message("Current t2_timers:\n#{UserVars.t2_timers.to_yaml}") if @debug

    @settings.t2_avoids.each do |avoid|
      if avoid['state']
        fput("avoid !#{avoid['type']}")
      else
        fput("avoid #{avoid['type']}")
      end
    end

    if !@args.nodelay && @settings.t2_startup_delay.to_i > 0
      DRC.message("Pausing due to t2_startup_delay.") if @debug
      pause until Time.now - DRSkill.start_time > @settings.t2_startup_delay
    end
  end

  def run
    loop do
      break if @shutdown

      trainables = @settings['training_list']
      EquipmentManager.new.empty_hands

      trainables.each do |trainable|
        # Skip if learning rate is above start threshold for this trainable
        if trainable['skill'].is_a?(Array)
          if @debug
            DRC.message("Checking all skills in #{trainable['skill']} to see if any are at or below #{trainable['start']}")
            skills_needing_training = trainable['skill'].each.reject { |skill| DRSkill.getxp(skill) >= trainable['start'] }
            if skills_needing_training.any?
              DRC.message("List of skills needing training: #{skills_needing_training.map { |skill| "#{skill} - (#{DRSkill.getxp(skill)})"}}.")
            else 
              DRC.message("No skills needed training, moving to next in list.")
              next
            end
          else
            next if trainable['skill'].each.reject { |skill| DRSkill.getxp(skill) >= trainable['start'] }.empty?
          end
        elsif DRSkill.getxp(trainable['skill']) >= trainable['start']
          DRC.message("Checked #{trainable['skill']} it did not need training, moving to next in list.") if @debug
          next
        else
          DRC.message("Checked #{trainable['skill']} - (#{DRSkill.getxp(trainable['skill'])}) it needs training.") if @debug
        end

        # Skip if the skill is still on cooldown between trainings
        if has_cooldown?(trainable['skill']) && !cooldown_expired?(trainable['skill'])
          if @debug
            DRC.message("Skill #{trainable['skill']} is still in cooldown:")
            DRC.message("  Now:                #{Time.now}")
            DRC.message("  Next Training Time: #{UserVars.t2_timers[trainable['skill']]+ @settings.exp_timers[trainable['skill']]}")
            DRC.message("Moving to next in list.")
          end
          next
        end

        # Skip if no moons are available
        # Lunar mages can use this setting to skip skills that require moons
        if trainable['moons'] && !DRCMM.moons_visible?
          if @debug
            DRC.message("Skill #{trainable['skill']} needs moons up, current moons:")
            DRC.message("  #{UserVars.moons['katamba']['pretty']}\n  #{UserVars.moons['yavash']['pretty']}\n  #{UserVars.moons['xibar']['pretty']}")
            DRC.message("Moving to next in list.")
          end
          next
        end

        # At this point we know that we need to train the skill
        if trainable['name'].nil?
          trainable_title = trainable['skill']
        else
          trainable_title = trainable['name']
        end
        echo "***STATUS*** Starting (#{trainable['start']}) #{trainable_title}"
        trainable_start_time = Time.now
        if @settings.t2_burgle_every_block
          echo "***STATUS*** Trying to burgle"
          DRC.wait_for_script_to_complete("burgle", ["start"])
        end
        execute_actions(trainable['scripts'])
        update_cooldown(trainable['skill']) if has_cooldown?(trainable['skill'])
        echo "***STATUS*** Completed #{trainable_title} in #{Time.at(Time.now - trainable_start_time).strftime("%Mm:%Ss")}"
        break
      end
    end
    if !@settings.t2_after_shutdown.empty?
      echo "***STATUS*** Controlled shutdown, executing shutdown actions."
      execute_actions(@settings.t2_after_shutdown)
    end
  end

  def has_cooldown?(skill)
    @settings.exp_timers.keys.include?(skill)
  end

  def cooldown_expired?(skill)
    UserVars.t2_timers[skill].nil? || Time.now - @settings.exp_timers[skill] >= UserVars.t2_timers[skill]
  end

  def update_cooldown(skill)
    UserVars.t2_timers[skill] = Time.now
  end

  def execute_actions(actions)
    echo "Action"
    actions.each do |action|
      echo "***STATUS*** EXECUTE #{action}"
      action_parts = action.split(' ')
      script_name = action_parts.shift
      DRC.wait_for_script_to_complete(script_name, action_parts)
    end
  end

  def shutdown
    if @shutdown
      DRC.message("T2 already set to shutdown.  Use '#{$clean_lich_char}e $T2.noshutdown' to cancel.")
    else
      @shutdown = true
      DRC.message("Shutting down T2 on next check.  Use '#{$clean_lich_char}e $T2.noshutdown' to cancel.")
    end
  end

  def noshutdown
    if @shutdown
      @shutdown = false
      DRC.message('Canceling shutdown of T2.')
    else
      DRC.message("T2 not set to shutdown.  Use '#{$clean_lich_char}e $T2.shutdown' to shutdown.")
    end
  end

  def reload_settings(debug = false)
    temp_settings = get_settings(@args.flex)

    if temp_settings.training_list.nil? ||
       temp_settings.training_list.class != Array ||
       temp_settings.training_list.empty?
      DRC.message("Detected invalid T2 settings - please double check your config")
      return
    end
    @settings = temp_settings
    DRC.message("T2 training_list reloaded.")
    echo @settings.training_list.to_yaml if debug
  end

  def debugon
    @debug = true
    DRC.message("T2 Debugging on")
  end

  def debugoff
    @debug = false
    DRC.message("T2 Debugging off")
  end
end

before_dying do
  scripts = ['magic', 'hunting-buddy', 'performance', 'athletics', 'first-aid', 'steal', 'outdoorsmanship', 'mech-lore', 'pick', 'foragetask']
  scripts.each do |script_name|
    stop_script(script_name) if Script.running?(script_name)
  end
  DRCA.release_cyclics(get_settings.cyclic_no_release)
end

$T2 = T2.new
$T2.run
$T2 = nil
