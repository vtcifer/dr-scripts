=begin
  Documentation: https://github.com/elanthia-online/dr-scripts/wiki/Documentation-for-sigilharvest.lic
=end

class SigilHarvest
  VERSION = '2.0.0'
  # === Experiment History (v1.2.0 → v1.5.27) ===
  # Retrospective simulation: 100% decision agreement (15/15). Net: v1.2.0 2.9% → v1.5.27 3.0%.
  #
  # v1.5.27 KEPT: EXP-18 — Min difficulty threshold. Skip trivial-difficulty (1) precision actions,
  #   forcing refresh. Avg gain 7.18→8.54 (+1.36), trivial 25.8%→3.6%, 60+ rate +6.9pp. Best since EXP-6.
  # v1.5.26 INFRA: D7 fix — Unconditional repair logging. Repairs=0 in 2606 iters. Phase 3/4 CLOSED.
  # v1.5.25 KEPT: EXP-17 — Resource-aware tiebreaker. On tied difficulty+cost, prefer most-available
  #   resource. Fires 9.4% of iters. Mishap -5.3pp (n.s. p=0.21), resource_exhausted -1.6pp.
  # v1.5.24 KEPT: EXP-14r — Cost equalization clean retest ({1,2,3}→{1,1,1}). Neutral (-1.6pp n.s.).
  # v1.5.23 REVERTED: EXP-16 — Resource coeff 1.75→1.5. Mathematically impossible (need prec>=18).
  # v1.5.22 REVERTED: EXP-15 — Move budget 14→15. Mishap +11.7pp, 0 scribes, sim scribe -0.2%.
  # v1.5.21 BASELINE: Corrected baseline. Restores EXP-9 resource exhaustion check.
  # v1.5.20 INFRA: Baseline restore + C1 fix. Reverts to v1.5.17 algorithm, adds @actually_scribed.
  # v1.5.19 REVERTED: EXP-14 — Cost equalization (confounded with EXP-13 cap removal). Mishap +11.4pp.
  # v1.5.18 REVERTED: EXP-13 — Remove iteration cap + move budget. Mishap +21.4pp (p=0.008).
  # v1.5.17 KEPT: Awakened technique. Avg gain +0.23, 80+ rate +2.1pp, sim scribe +0.4%.
  # v1.5.16 REVERTED: EXP-12r — Loosen viability margin retest. Confirmed first test was noise.
  # v1.5.15 KEPT: EXP-9 — Resource exhaustion coeff 2.25→1.75. Neutral (sim -0.1%).
  # v1.5.14 REVERTED: EXP-12 — Loosen viability margin (margin=0 for challenging+). Mishap +6.6pp.
  # v1.5.13 KEPT: EXP-7 — Difficulty-based action selection (decouple risk from cost). Neutral.
  # v1.5.12 KEPT: EXP-10 — Skip threshold <13 (standalone retest of v1.5.11). Neutral.
  # v1.5.11 REVERTED: EXP-10+11 — Skip+velocity bundled. EffGain collapsed (-14.1), avg iters 7.0.
  # v1.5.10 KEPT: EXP-6 — Fix difficulty ordering + filter ACTION verb. Mishap -0.79pp/iter (p=0.02).
  # v1.5.9 NEUTRAL: Illuminated technique test. No algorithm change.
  # v1.5.8 KEPT: EXP-5 — Tighten move budget formula (15→13 precision/move). Sim scribe +0.3%.
  # v1.5.7 INFRA: Baseline restore (EXP-4 reverted).
  # v1.5.6 REVERTED: EXP-4 — Composite resource health guard. Skipped too many sigils.
  # v1.5.5 REVERTED: EXP-3 — Prefer repair over trivial/straightforward precision actions.
  # v1.5.4 KEPT: EXP-2 — Accept trivial actions + burin validate_tools fix.
  # v1.5.0–v1.5.3: Algorithm rewrite, patches, baseline establishment.
  # v1.2.0: Original baseline (Matt). Risk-based selection. Sim scribe 2.9%.

  def initialize
    @sigil_list = %w[abolition congruence induction permutation rarefaction antipode ascension clarification decay evolution integration metamorphosis nurture paradox unity]

    arg_definitions = [
      [
        { name: 'city', regex: /\w+/, description: 'Region to find sigils in: Shard, Crossing, Riverhaven' },
        { name: 'sigil', regex: /\w+/, description: "Type of sigil to harvest OR enter 'random' to target a random sigil." },
        { name: 'precision', regex: /\d+/, description: 'Precision target.' },
        { name: 'minutes', regex: /\d+/, optional: true, description: 'Session time limit in minutes (default: 30)' },
        { name: 'debug', regex: /debug/i, optional: true, description: 'Provides extra debug information while the script runs' }
      ]
    ]

    # patterns which signal that the sigil hunting process is proceeding successfully but a sigil has not yet been found
    @search_patterns = [/^You clear your mind/,
                        /^Left and right you crane your head/,
                        /^Back and forth you walk/,
                        /^You close your eyes and turn to a random direction/,
                        /^You scour the area looking for hints of sigil lore patterned upon the ground/,
                        /^Whorls of dust upon the ground catch your eye/,
                        /^The sky holds your interest/,
                        /^The ceiling holds your interest/]

    # patterns that signal a sigil has been detected
    @found_patterns = /After much scrutiny|Through the seemingly mundane lighting|Almost obscured by the surroundings|Subtleties in the surroundings|The area contains signs of a sigil|In your mind's eye|Sorting through the imagery/

    # patterns for detecting the type of sigil found
    @sigil_patterns = /(abolition|congruence|induction|permutation|rarefaction|antipode|ascension|clarification|decay|evolution|integration|metamorphosis|nurture|paradox|unity) sigil/

    # patterns that detect when sigil improvement has failed
    @mishaps = /Chills creep down your spine|About the area you wander|A sudden sneeze|You lose track|You prepare yourself for continued exertion|You are too distracted/

    # Resource cost descriptors: taxing=resolve, disrupting=focus, destroying=sanity.
    # Each action costs ~4.2 stars of exactly one resource (100% correlation, 2416 actions).
    # EXP-14 retest (v1.5.24) confirmed: {1,1,1} is neutral vs baseline (mishap -1.6pp, n.s.)
    # Original "harmful" verdict was confounded by EXP-13's broken code base.
    @action_cost = { "taxing" => 1, "disrupting" => 1, "destroying" => 1 }

    # numerical values for ranking difficulty of improvement action in the minigame
    @action_difficulty = { "trivial" => 1, "straightforward" => 2, "formidable" => 3, "challenging" => 4, "difficult" => 5 }

    @settings = get_settings
    @burin = @settings.enchanting_tools.find { |item| /burin/ =~ item } || 'burin'
    @bag = @settings.crafting_container
    @belt = @settings.enchanting_belt
    @bag_items = @settings.crafting_items_in_container
    @danger_rooms = @settings.sigil_harvest_settings['danger_rooms']
    @stock_scrolls = @settings.sigil_harvest_settings['blank_scrolls']
    @season = get_season
    @techniques = get_techniques
    @data = get_data('sigils')
    @enemy_rooms = []

    @args = parse_args(arg_definitions)
    @debug = @args.debug
    @sigil_count = 0
    @sigil_results = []
    @start_time = Time.now
    @time_limit = (@args.minutes || 30).to_i
    @rooms_visited = 0

    log_startup_banner

    tool_errors = validate_tools
    unless tool_errors.empty?
      tool_errors.each { |e| DRC.message("  ERROR: #{e}") }
      log_exit_summary
      return
    end
    DRC.message("  Burin resolved:   '#{@burin}' (#{@burin_belt ? 'belt' : 'pack'})")

    DRCA.do_buffs(@settings, 'outdoors')

    Flags.add('sigilharvest-found', @found_patterns)
    Flags.add('sigilharvest-type', @sigil_patterns)
    Flags.add('sigilharvest-noactions', /You are unable to perceive any opportunities for improving the sigil/)

    DRC.message("Finding #{@args.sigil.downcase} sigils near #{@args.city.capitalize}")

    startroom = Room.current.id
    get_scrolls
    find_sigils(@args.city.capitalize, @args.sigil.downcase)
    DRCT.walk_to(startroom)

    if @enemy_rooms.length > 0
      DRC.message("Enemies were encountered in the following rooms: #{@enemy_rooms}")
      DRC.message("Consider adding them to danger_rooms under sigil_harvest_settings in your YAML.")
    end

    log_exit_summary
  end

  def find_sigils(city, sigil)
    loop do
      sigil = @sigil_list.sample if @args.sigil.downcase == 'random'

      roomlist = @data.SigilInfo.dig(city, sigil, @season)
      DRC.message("Harvesting #{sigil} sigils from #{roomlist.length} known rooms in the vicinity of #{@args.city.capitalize}.") if @debug

      roomlist.each do |room|
        next if @danger_rooms.include?(room)
        break if time_expired?

        DRCA.do_buffs(@settings, 'outdoors')
        DRCT.walk_to(room)

        @rooms_visited += 1
        @num_iterations = 0
        @num_aspect_repairs = 0

        harvest_sigil(sigil)
      end

      break if time_expired?
    end
  end

  def harvest_sigil(sigil)
    @sigil_count += 1
    @sigil_start_time = Time.now
    sigil_result = 'FAILED'
    @sigil_precision = 0
    @danger_lvl = 0
    @actually_scribed = false

    # sigil finding loop
    loop do
      case DRC.bput('perc sigil', @found_patterns, @search_patterns, /You are too distracted/, /You recall|Having recently been searched|You are already/)
      when /You are too distracted/
        DRC.message("Enemies detected. Consider adding room #{Room.current.id} to personal no-go list in your character-setup YAML.")
        @enemy_rooms.push(Room.current.id)
        log_sigil_summary(sigil, 'SKIPPED')
        return false
      when /You recall|Having recently been searched|You are already/
        DRC.message('This room does not contain the desired sigil or has been searched too recently.') if @debug
        log_sigil_summary(sigil, 'SKIPPED')
        return false
      end
      waitrt?

      if Flags['sigilharvest-found']
        flagstring = Flags['sigilharvest-type'].to_s.gsub(/ sigil/, '')
        DRC.message("Sigil found: #{flagstring}") if @debug
        Flags.reset('sigilharvest-found')
        Flags.reset('sigilharvest-type')
        break if flagstring.downcase == sigil
      else
        pause 0.2
      end
    end

    # kick off the improvement loop
    if sigil_info('improve')
      while improve_sigil(@args.precision.to_i)
        DRC.message("Current Precision: #{@sigil_precision} | Target Precision: #{@args.precision} | Danger Modifier: #{(@danger_lvl * 0.5).floor}") if @debug
      end
      # C1 fix (v1.5.20): Use @actually_scribed flag instead of precision check.
      # The old check `@sigil_precision >= (target - 5)` misclassified high-precision
      # mishaps as SCRIBED (50% of all SCRIBED results were fakes).
      sigil_result = 'SCRIBED' if @actually_scribed
    else
      log_sigil_summary(sigil, sigil_result)
      return false
    end

    log_sigil_summary(sigil, sigil_result)
    true
  end

  def check_sigil(sigil)
    DRC.message('Checking if this is the desired sigil') if @debug

    /\) (\w+) sigil/ =~ DRC.bput('perc sigil info', /^You have perceived an? \w+ \(Clarity:\d+\) (\w+) sigil comprised of broad strokes \(Precision:\d+\) in the area.*/)
    @sigil_type = $1
    DRC.message("Sigil type found: #{@sigil_type} - Sigil target: #{sigil}") if @debug

    if @sigil_type == sigil
      DRC.message("Desired sigil found! #{@sigil_type}") if @debug
      true
    else
      DRC.message("This is not the sigil we are looking for.") if @debug
      false
    end
  end

  def improve_sigil(precision)
    waitrt?

    sigil_action = {}
    aspect_repair = {}
    best_repair_aspect = {}
    second_best_repair_aspect = {}
    repair_override = false

    # --- Phase 1: Pre-scan for repair candidates ---
    # Identify precision actions that are too difficult to execute, so we can repair
    # the resource they consume.
    @sigil_improvement.each do |x|
      contest_stat = contest_stat_for(x['resource'])
      next unless x['aspect'] == 'precision' && (contest_stat - x['difficulty'].to_i < 2) && (x['difficulty'].to_i >= 3)

      if best_repair_aspect.key?("difficulty")
        if x['difficulty'].to_i > best_repair_aspect['difficulty'].to_i
          second_best_repair_aspect = best_repair_aspect
          best_repair_aspect = x
        end
      else
        best_repair_aspect = x
        DRC.message('Best repair option selected') if @debug
      end
    end

    # --- Phase 2: Select precision action and repair opportunities ---
    @sigil_improvement.each do |x|
      contest_stat = contest_stat_for(x['resource'])

      DRC.message("Aspect: #{x['aspect']} -> Precision Comparison #{@sigil_precision}|#{precision} -> Risk|Stat: #{x['risk']}|#{contest_stat}") if @debug

      # Select a precision upgrade action.
      # Conditions: stat must have enough margin over difficulty, and difficulty must be non-trivial
      # (unless danger is high or precision is close to target).
      # Skip ACTION verb — 24.8% zero-gain rate (EXP-6).
      if x['aspect'] == 'precision' && x['verb'].upcase != 'ACTION' && precision_action_viable?(x, contest_stat, precision)
        DRC.message("Potential precision upgrade found... ") if @debug

        if sigil_action.key?("difficulty")
          # EXP-7: Select by difficulty (determines gain), break ties by cost (conserve resources).
          # Data shows gain is determined entirely by difficulty (trivial=2.3 to difficult=13.3),
          # cost has zero correlation with gain. Decoupling from risk composite.
          if x['difficulty'].to_i > sigil_action['difficulty'].to_i
            sigil_action = x
          elsif x['difficulty'].to_i == sigil_action['difficulty'].to_i && x['impact'].to_i < sigil_action['impact'].to_i
            sigil_action = x
          elsif x['difficulty'].to_i == sigil_action['difficulty'].to_i && x['impact'].to_i == sigil_action['impact'].to_i
            # EXP-17 (v1.5.25): Resource-aware tiebreaker — when difficulty and cost are equal,
            # prefer the action that drains the most-available resource. This preserves scarce
            # resources for future iterations. Fires in ~9.4% of iterations (all ties have
            # heterogeneous cost profiles, so every tie offers a meaningful resource choice).
            if contest_stat_for(x['resource']) > contest_stat_for(sigil_action['resource'])
              sigil_action = x
            end
          end
        else
          sigil_action = x
          DRC.message('Storing new verb for precision improvement') if @debug
        end
      end

      # Check best repair opportunity: an action that restores the resource consumed by
      # the hardest precision action we identified
      select_repair_action(x, contest_stat, precision, best_repair_aspect, aspect_repair) do |selected|
        aspect_repair = selected
        repair_override = true
      end

      # Check second-best repair opportunity
      select_repair_action(x, contest_stat, precision, second_best_repair_aspect, aspect_repair) do |selected|
        aspect_repair = selected
        repair_override = true
      end
    end

    DRC.message("Iteration #: #{@num_iterations}")

    # --- Phase 3: Early bail-out checks ---

    # Hard iteration cap: stop after 15 iterations.
    # v1.5.17 guardrail restored in v1.5.20 after EXP-13 proved removal catastrophic.
    if @num_iterations >= 15
      if @sigil_precision >= (precision - 5)
        DRC.message("Current Precision: #{@sigil_precision} | Target Precision: #{@args.precision}") if @debug
        DRC.message("Final precision: #{@sigil_precision}, scribing (iteration cap)")
        scribe_sigils
        return false
      else
        DRC.message("Exiting: iteration cap reached at precision #{@sigil_precision}")
        DRC.message("Final precision: #{@sigil_precision}")
        return false
      end
    end

    # Move budget check: estimate whether remaining iterations can plausibly reach target.
    # Formula: (max_useful_iters - used) * precision_per_move < remaining_gap
    # 14 = max useful iterations, 13 = precision/move coefficient (EXP-5), 5 = scribe buffer
    # v1.5.17 guardrail restored in v1.5.20. EXP-15 (14→15) reverted — harmful.
    if (14 - @num_iterations) * 13 < (precision - @sigil_precision - 5)
      DRC.message("Exiting: insufficient moves to reach target")
      DRC.message("Final precision: #{@sigil_precision}")
      return false
    end

    # Scribe if precision target reached
    if @sigil_precision >= precision
      DRC.message("Current Precision: #{@sigil_precision} | Target Precision: #{@args.precision}") if @debug
      DRC.message("Final precision: #{@sigil_precision}, scribing")
      scribe_sigils
      return false
    else
      DRC.message("Current Precision: #{@sigil_precision} | Target Precision: #{@args.precision}") if @debug
    end

    # --- Phase 4: Apply repair if no precision action available ---
    if (@num_aspect_repairs < 2 || repair_override) && !sigil_action.key?("difficulty")
      if @danger_lvl <= 18 && aspect_repair.key?("difficulty")
        DRC.message('Executing aspect repair')
        sigil_action = aspect_repair
        @num_aspect_repairs += 1
      end
    end

    # Execute chosen action or refresh available actions
    if sigil_action.key?("difficulty")
      return false unless sigil_info(sigil_action['verb'])
    else
      return false unless sigil_info('improve')
    end

    true
  end

  def sigil_info(command)
    case results = DRC.bput("perc sigil #{command}", /^You have perceived a.*/, @mishaps)
    when @mishaps
      DRC.message("Final precision: #{@sigil_precision}")
      DRC.message('Sigil harvesting failed') if @debug
      return false
    else
      /\(Clarity:(\d+)\).*\(Precision:(\d+)\).*/ =~ results
      @sigil_clarity = $1.to_i
      @sigil_precision = $2.to_i
    end

    # Skip <15 for target 90 removed in v1.5.20: SIM-7 showed ALL scribes started at
    # precision 13, which would be killed by the <15 threshold.

    if @args.precision.to_i >= 80 && @sigil_precision < 13
      DRC.message("Target precision >= 80, moving on as starting precision is below 13")
      return false
    end

    improvements = []
    @sigil_improvement = []

    if Flags['sigilharvest-noactions']
      Flags.reset('sigilharvest-noactions')
      DRC.message("No actions remain. Generating new actions...") if @debug
      return true
    end

    # Capture improvement actions from game output
    DRC.message("Entering improvement capture loop...") if @debug
    loop do
      improvements.push(waitfor(/^\.|^You also take the opportunity to take stock of your mental health\.|^You are unable to perceive any opportunities for improving the sigil\./))

      if improvements.last =~ /^You also take the opportunity to take stock of your mental health\.|^You are unable to perceive any opportunities for improving the sigil\./
        improvements.pop
        break
      end
    end

    # Parse each improvement action
    improvements.each_with_index do |x, index|
      /^\.\.\.a (\w+), (\w+) (\w+) (\w+).*(your|sigil) (\w+)\.?$/ =~ x
      @sigil_improvement[index] = {
        "difficulty" => @action_difficulty[$1],
        "resource"   => $2,
        "impact"     => @action_cost[$3],
        "verb"       => $4,
        "target"     => $5,
        "aspect"     => $6,
        "risk"       => (@action_difficulty[$1].to_i + @action_cost[$3].to_i)
      }
    end

    # Parse minigame resource stats
    danger_str = waitfor "Danger:"
    sanity_str = waitfor "Sanity:"
    resolve_str = waitfor "Resolve:"
    focus_str = waitfor "Focus:"

    @danger_lvl = danger_str.split('*').length - 1
    @sanity_lvl = sanity_str.split('*').length - 1
    @resolve_lvl = resolve_str.split('*').length - 1
    @focus_lvl = focus_str.split('*').length - 1

    # Resource exhaustion check (EXP-9): bail out if remaining resources can't
    # plausibly reach scribe threshold. Coefficient = precision headroom per star.
    # EXP-16 tried 1.5 but that's mathematically impossible (need prec>=18 at max resources).
    # Minimum viable coefficient for target 90: (85 - 13) / 45 = 1.6. Keeping 1.75.
    available = (@sanity_lvl + @resolve_lvl + @focus_lvl) * 1.75 + @sigil_precision
    if available < (@args.precision.to_i - 5)
      DRC.message("Exiting: available resources (#{available}) below target precision - 5")
      DRC.message("Final precision: #{@sigil_precision}")
      return false
    end

    # Trader luck: on first iteration with decent starting precision, speculate for better RNG
    if @sigil_precision >= 14 && @num_iterations == 0
      if DRStats.trader? && DRStats.circle >= 65
        waitrt?
        fput('speculate luck')
      end
    end

    @num_iterations += 1
    true
  end

  def scribe_sigils
    @actually_scribed = true
    DRCI.stow_hands
    DRCI.get_item?('blank scrolls')
    get_burin

    scribe_count = 0
    loop do
      case DRC.bput('scribe sigil', /You carefully/, /You should/)
      when /You carefully/
        scribe_count += 1
        DRCC.stow_crafting_item('sigil-scroll', @bag, @belt)
        DRC.bput('get blank scroll', /You pick/, /You get/)
      when /You should/
        break
      end
    end

    DRC.message("Scribes: #{scribe_count}")

    stow_burin
    DRCC.stow_crafting_item('blank scroll', @bag, @belt)
    fput('stow feet')
    get_scrolls
  end

  def get_season
    /^It is currently (\w+) and it is.*$/ =~ DRC.bput('time', /^It is currently.*/)
    $1.downcase
  end

  def get_techniques
    lines = Lich::Util.issue_command(
      'craft artificing',
      /^From the artificing crafting discipline|^You have no knowledge/,
      silent: true, quiet: true, timeout: 3
    )
    response = lines.first.to_s.strip
    return [] if response =~ /no crafting techniques/ || response =~ /no knowledge/

    if response =~ /have been trained in (.+)\.\s*$/
      all = $1.split(/,\s*|\s+and\s+/).map(&:strip)
      all.select { |t| t =~ /Sigil Comprehension/ }
    else
      []
    end
  rescue StandardError
    []
  end

  def get_scrolls
    target_scrolls = @stock_scrolls || 25
    num_scrolls = DRCI.count_item_parts('blank scroll')
    DRC.message("Scrolls remaining: #{num_scrolls}") if @debug

    return if num_scrolls >= target_scrolls

    case @args.city
    when /crossing/i
      scroll_room = 14754
      scroll_price = 125 # kronars
    when /riverhaven/i
      scroll_room = 14770
      scroll_price = 100 # lirums
    when /shard/i
      scroll_room = 14772
      scroll_price = 90 # dokora
    when /hib|hibbles|hibarnhvidar/i
      scroll_room = 15522
      scroll_price = 90 # dokora
    end

    DRC.message("Buying scrolls from #{Room[scroll_room].title}") if @debug

    DRCI.stow_hands

    num_to_order = ((target_scrolls - num_scrolls) / 25.0).ceil
    coppers_needed = num_to_order * scroll_price

    DRC.message("Getting #{coppers_needed} coppers to buy scrolls.") if @debug
    DRCM.ensure_copper_on_hand(coppers_needed, @settings)

    DRC.message("Ordering scrolls #{num_to_order} times.") if @debug
    (1..num_to_order).each do
      DRCT.order_item(scroll_room, 8)
      DRC.bput('combine', /^You combine|^You must/)
    end

    DRC.bput('combine', /^You combine|^You must/) if DRCI.get_item?('blank scroll', @bag)
    DRCC.stow_crafting_item('blank scroll', @bag, @belt)
  end

  private

  def validate_tools
    errors = []
    errors << "No crafting container configured (crafting_container setting)" if @bag.nil? || @bag.empty?
    errors << "No sigil_harvest_settings configured" if @settings.sigil_harvest_settings.nil?
    return errors unless errors.empty?

    DRCI.stow_hands
    resolve_burin(errors)
    errors
  end

  # Determine which burin name and stow method works for this character.
  # Sets @burin (resolved name) and @burin_belt (belt ref or nil).
  def resolve_burin(errors)
    belt_name = @belt.is_a?(Hash) ? @belt['name'] : @belt

    # Attempt 1: Settings name from belt (e.g., "untie my precise burin from my toolbelt")
    if belt_name
      result = DRC.bput("untie my #{@burin} from my #{belt_name}",
                        /You untie/, /Untie what/, /You are not wearing/)
      if result =~ /You untie/
        @burin_belt = @belt
        DRC.bput("tie my #{@burin} to my #{belt_name}", /You (?:tie|attach)/, /doesn't seem to fit/)
        return
      end
    end

    # Attempt 2: Settings name from bag (e.g., "get my precise burin")
    result = DRC.bput("get my #{@burin}",
                      /You get/, /You pick/, /What were you/, /You are already/)
    if result =~ /You get|You pick|already/
      @burin_belt = nil
      fput("stow my #{@burin}")
      return
    end

    # Attempt 3: Plain 'burin' — may be in bag or redirect to belt untie
    result = DRC.bput('get my burin',
                      /You get/, /You pick/, /What were you/, /You are already/,
                      /You should untie .+ from .+ first/)
    if result =~ /You get|You pick|already/
      @burin = 'burin'
      @burin_belt = nil
      fput('stow my burin')
      return
    end

    # Attempt 4: Game told us "You should untie the <name> from the <belt>"
    # Parse the actual item name and retry untie with it.
    if result =~ /You should untie/ && belt_name
      if result =~ /untie the (.+?) from/
        real_name = $1
        untie_result = DRC.bput("untie my #{real_name} from my #{belt_name}",
                                /You untie/, /Untie what/)
        if untie_result =~ /You untie/
          @burin = real_name
          @burin_belt = @belt
          DRC.bput("tie my #{real_name} to my #{belt_name}", /You (?:tie|attach)/, /doesn't seem to fit/)
          return
        end
      end
    end

    errors << "Could not find any burin in inventory or on belt"
  end

  def get_burin
    if @burin_belt
      DRCC.get_crafting_item(@burin, @bag, @bag_items, @burin_belt)
    else
      DRC.bput("get my #{@burin}", /You get/, /You pick/, /What were you/, /You are already/)
    end
  end

  def stow_burin
    if @burin_belt
      DRCC.stow_crafting_item(@burin, @bag, @burin_belt)
    else
      fput("stow my #{@burin}")
    end
  end

  def log_startup_banner
    DRC.message("== SigilHarvest v#{VERSION} ==")
    DRC.message("  City:             #{@args.city}")
    DRC.message("  Sigil:            #{@args.sigil}")
    DRC.message("  Target prec:      #{@args.precision}")
    DRC.message("  Time limit:       #{@time_limit} minutes")
    DRC.message("  Debug:            #{@debug ? 'true' : 'false'}")
    DRC.message("  Season:           #{@season}")
    DRC.message("  Techniques:       #{format_techniques(@techniques)}")
    DRC.message("  Burin:            #{@burin}")
    DRC.message("  Bag:              #{@bag}")
    DRC.message("  Danger rooms:     #{@danger_rooms}")
    DRC.message("  Stock scrolls:    #{@stock_scrolls}")
    DRC.message("  Enchanting tools: #{@settings.enchanting_tools}")
    DRC.message("========================")
  end

  def log_sigil_summary(sigil, result)
    prec = @sigil_precision || 0
    danger = @danger_lvl || 0
    iters = @num_iterations || 0
    sigil_elapsed = sigil_elapsed_minutes
    DRC.message("[Sigil ##{@sigil_count}] type=#{sigil} result=#{result} precision=#{prec}/#{@args.precision} iterations=#{iters} danger=#{danger} room=#{@rooms_visited} elapsed=#{sigil_elapsed}m total=#{elapsed_minutes}m")
    @sigil_results << { number: @sigil_count, type: sigil, result: result, precision: prec, target: @args.precision.to_i, iterations: iters, danger: danger, room: @rooms_visited, elapsed: sigil_elapsed }
  end

  def log_exit_summary
    total = @sigil_results.size
    scribed = @sigil_results.count { |r| r[:result] == 'SCRIBED' }
    failed = @sigil_results.count { |r| r[:result] == 'FAILED' }
    skipped = @sigil_results.count { |r| r[:result] == 'SKIPPED' }
    attempted = @sigil_results.reject { |r| r[:result] == 'SKIPPED' }
    avg_prec = attempted.empty? ? 0 : (attempted.sum { |r| r[:precision] } / attempted.size.to_f).round(1)
    avg_iters = attempted.empty? ? 0 : (attempted.sum { |r| r[:iterations] } / attempted.size.to_f).round(1)
    best = attempted.max_by { |r| r[:precision] }

    DRC.message("== Session Summary ==")
    DRC.message("  City:             #{@args.city}")
    DRC.message("  Sigil:            #{@args.sigil}")
    DRC.message("  Target prec:      #{@args.precision}")
    DRC.message("  Time limit:       #{@time_limit} minutes")
    DRC.message("  Run time:         #{elapsed_minutes} minutes")
    DRC.message("  Rooms visited:    #{@rooms_visited}")
    DRC.message("  ---")
    DRC.message("  Sigils total:     #{total}")
    DRC.message("  Scribed:          #{scribed}")
    DRC.message("  Failed:           #{failed}")
    DRC.message("  Skipped:          #{skipped}")
    DRC.message("  Success rate:     #{total > 0 ? ((scribed.to_f / total) * 100).round(1) : 0}%")
    DRC.message("  Avg precision:    #{avg_prec} (non-skipped)")
    DRC.message("  Avg iterations:   #{avg_iters} (non-skipped)")
    DRC.message("  Best sigil:       ##{best[:number]} precision=#{best[:precision]}/#{best[:target]} iterations=#{best[:iterations]}") if best
    DRC.message("== End SigilHarvest v#{VERSION} ==")
  end

  def format_techniques(techniques)
    return 'none' if techniques.nil? || techniques.empty?

    techniques.map { |t| t.gsub(' Sigil Comprehension', '') }.join(', ')
  end

  def elapsed_minutes
    ((Time.now - @start_time) / 60.0).round(1)
  end

  def sigil_elapsed_minutes
    ((Time.now - (@sigil_start_time || @start_time)) / 60.0).round(1)
  end

  def time_expired?
    elapsed_minutes >= @time_limit
  end

  # Returns the current minigame stat level for a given resource name
  def contest_stat_for(resource)
    case resource
    when 'sanity'  then @sanity_lvl.to_i
    when 'resolve' then @resolve_lvl.to_i
    when 'focus'   then @focus_lvl.to_i
    else 0
    end
  end

  # Determines whether a precision action is viable given the current contest stat and danger level.
  # Actions require sufficient stat margin over difficulty. Trivial actions (difficulty=1) are
  # accepted when margin allows — a trivial action (+2 avg) beats a refresh (+0).
  def precision_action_viable?(action, contest_stat, _precision)
    difficulty = action['difficulty'].to_i
    margin = contest_stat - difficulty

    # EXP-18 (v1.5.27): Skip trivial-difficulty (1) precision actions.
    # Trivial avg gain=2.3 vs 6.8+ for formidable+. Refreshing for a better menu is
    # +EV: P(non-trivial)*avg_gain = 74%*8.0=5.9 >> 2.3. See gain optimization analysis.
    return false if difficulty < 2

    # Path 1: comfortable margin (>1) — accept straightforward+ difficulty
    return true if margin > 1

    # Path 2: margin (>0) AND challenging+ difficulty
    # EXP-12 tested margin >= 0 twice (v1.5.14, v1.5.16). Both showed increased mishap rate
    # (+6.6pp, +4.6pp) without consistent improvement in >=80 outcomes. Keeping margin > 0.
    return true if margin > 0 && difficulty > 2

    false
  end

  # Checks if the given action can serve as a repair for a depleted resource.
  # Yields the selected repair action if it qualifies.
  def select_repair_action(action, contest_stat, precision, repair_target, current_repair)
    return unless action['difficulty'].to_i <= 3
    return unless repair_target.key?("difficulty")
    return unless (contest_stat - action['difficulty'].to_i) >= 2
    return unless @sigil_precision >= (precision - 15)
    return unless action['aspect'] == repair_target['resource']

    if current_repair.key?("difficulty")
      yield action if current_repair['risk'] > action['risk']
    else
      DRC.message('Storing new verb for aspect repair') if @debug
      yield action
    end
  end
end

before_dying do
  Flags.delete('sigilharvest-found')
  Flags.delete('sigilharvest-type')
  Flags.delete('sigilharvest-noactions')
end

SigilHarvest.new
