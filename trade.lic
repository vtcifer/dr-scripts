=begin
  Documentation: https://elanthipedia.play.net/Lich_script_repository#trade
=end
custom_require.call(%w[common common-items common-arcana common-crafting common-money common-travel drinfomon equipmanager events])

class Trade
  include DRC
  include DRCA
  include DRCT
  include DRCI
  include DRCC
  include DRCM

  def initialize
    arg_definitions = [
      [
        { name: 'destination', regex: /\d+/i, optional: true, description: 'Give a room ID to bring your caravan to' }
      ],
      [
        { name: 'closeup', regex: /closeup/i, optional: false, description: 'Close up by delivering all remaining crates and accepting no new contracts' },
        { name: 'exit', regex: /exit/i, optional: true, description: 'Exits the game after delivering all crates and returning the caravan' }
      ],
      [
        { name: 'outpost', regex: /outpost/i, optional: false, description: 'Bring the caravan to the trade outpost of a town.' },
        { name: 'town_name', regex: /\w+/i, variable: true, description: 'First word of the town name.' }
      ],
      [
        { name: 'duration', regex: /duration/i, optional: false, description: 'Run for a certain amount of time plus the time required to closeup.' },
        { name: 'minutes', regex: /\d+/i, optional: false, variable: true, description: 'Duration of the run in minutes.' },
        { name: 'hunt', regex: /hunt/i, optional: true, description: 'If Trading xp is above half, hunt occasionally using hunting_info: defined in <name>-caravanhunt.yaml' },
        { name: 'exit', regex: /exit/i, optional: true, description: 'Exits the game after delivering all crates and returning the caravan' }
      ],
      [
        { name: 'hunt', regex: /hunt/i, optional: false, description: 'If Trading xp is above half, hunt occasionally using hunting_info: defined in <name>-caravanhunt.yaml' }
      ]
    ]

    echo '**********************************************************************'
    echo '**** DETAILS ON SCRIPT USAGE AND CONFIGURATION CAN BE FOUND ON    ****'
    echo '**** https://github.com/rpherbig/dr-scripts/wiki/Trader-Tutorials ****'
    echo '**********************************************************************'

    args = parse_args(arg_definitions)
    @closeup = args.closeup
    @exit = args.exit
    @hunt = args.hunt
    @caravan = OpenStruct.new
    @duration = args.minutes

    @town_data = get_data('town')
    @crafting_data = get_data('crafting')
    @recipe_data = get_data('recipes')
    @equipment_manager = EquipmentManager.new
    @settings = get_settings
    @contract_container = @settings.trade_contract_container
    @trading_towns = {}
    @province = nil
    @last_seen_caravan = []
    @no_lead_towns = ['Riverhaven', "Muspar'i"]
    @caravan_room_descriptions = { 'goat-drawn' => 'frenzied goats' }
    @bank_towns = ['Riverhaven', "Muspar'i", 'Hibarnhvidar', 'Therenborough', 'Crossing', 'Shard', 'Leth Deriel']
    @inconvenient_towns = ['Dirge', 'Riverhaven', "Muspar'i", 'Leth Deriel', 'Ain Ghazal'] # towns that are more difficult to get to than normal
    @no_ride_rooms = ['Interior', 'Hodierna', 'Kertigen', 'Damaris', 'Evening', 'Ferry', 'Star', 'Northern' 'Lounge', 'Deck', 'Wharf', 'Desert', 'South Bank', 'Gondola', 'Platform', 'Pier', 'Riverhaven', 'Theren', 'Suncatcher', 'Dock']
    @no_forage_rooms = @no_ride_rooms + ['Crossing', 'Lava', 'Dirge', 'Ghazal', 'Hibarnhvidar', 'Mountain', 'Dock', 'Theren', 'Muspar', 'Arnshal', "Ker'leor", 'Shard', 'Fayrin', 'Hvaral']
    @outside_exits = { 'Crossing' => ['go doors', 'out'], 'Arthe Dale' => ['go door', 'out'], 'Stone Clan' => ['go outpost', 'out'],
                       'Dirge' => ['go dingy stables', 'out'], 'Leth Deriel' => ['go shanty', 'out'], 'Tiger Clan' => ['go outpost', 'out'], 'LethFerry' => %w[south north],
                       'Wolf Clan' => ['go outpost', 'out'], 'Shard' => ['go arch', 'out'], 'Darkling Wood' => ['go building', 'out'],
                       "Fayrin's Rest" => ['go outpost', 'out'], 'Steelclaw Clan' => ['go entrance', 'out'], 'Hibarnhvidar' => ['go guild', 'out'],
                       'Boar Clan' => ['go building', 'out'], "Raven's Point" => ['go outpost', 'go pine door'], 'Ain Ghazal' => %w[west east],
                       'Fornsted' => 'go gate', 'Langenfirth' => %w[south north], 'Hvaral' => 'go gate', 'Therenborough' => 'go gate' }
    @emergency_delivery_town = nil
    @current_caravan_destination = nil
    @caravan_coins_on_hand = @settings.caravan_coins_on_hand.to_i
    @use_stable = @settings.trade_use_stable
    @caravan_interior = @settings.caravan_interior
    @caravan_being_led = false
    @held_contracts = []
    @force_contract_from = []
    @inconvenient_contract_threshold = 0
    Flags.add('lead-arrived', '^The .* stops and waits, having arrived at its destination', '^You feel the momentum of the room shift and then hear a voice from outside announce')
    Flags.add('lead-failed', '^Your caravan guide comes to you and suggests')
    Flags.add('caravan-arrived', /^Your .*, following you/)
    Flags.add('trade-bescort', '^The sand barge pulls into dock', '^The .* reaches (the|its) dock and its crew ties the (barge|ferry) off', '^You come to a very soft stop')
    Flags.add('trade-barge', '^A bargeman signals to the driver')

    # TRAINING
    @gem_pouch_adjective = @settings.gem_pouch_adjective
    @full_pouch_container = @settings.full_pouch_container
    @training_spells = @settings.crafting_training_spells
    @worn_instrument = @settings.worn_instrument
    @use_storage_box = DRStats.circle >= 35
    @step_toggle = -1
    @worn_feedbag = true
    wipe_token

    @equipment_manager = EquipmentManager.new(@settings)
    @cooldown_timers = {}
    @crafting_override = @settings.caravan_recipes
    @caravan_training_skills = @settings.caravan_training_skills
    @all_skills = ['Attunement', 'Warding', 'Augmentation', 'Utility', 'Appraisal', 'Forging',
                   'Perception', 'Locksmithing', 'First Aid', 'Outfitting', 'Engineering', 'Performance', 'Outdoorsmanship', 'Athletics']
    @caravan_training_skills.select! { |skill, _cooldown| @all_skills.include?(skill) }
    @lead_training_skills = @caravan_training_skills.reject { |skill, _cooldown| %w[Forging Augmentation Utility Warding].include?(skill) }
    @walk_training_skills = @caravan_training_skills.select { |skill, _cooldown| %w[Augmentation Utility Warding Attunement Performance Appraisal].include?(skill) }
    @craft_bag = @settings.crafting_container
    @craft_belt = nil
    @appraisal_queue = ['instrument', 'pouch', 'full-pouch', 'bundle']

    @outfitting_material_type = should_knit? ? 'wool yarn' : 'burlap cloth'
    yarn_quantity = @settings.yarn_quantity > 300 ? 301 : @settings.yarn_quantity
    @outfitting_quantity = should_knit? ? yarn_quantity : 50
    @lumber_quantity = @settings.lumber_quantity > 30 ? 30 : @settings.lumber_quantity
    @current_materials = {}
    @current_grass_count = 100
    @times_outfitting = 0
    @times_engineering = 0

    @box = @settings.picking_lockbox
    @worn_lockbox = @settings.picking_worn_lockbox
    @loot_nouns = @settings.lootables
    @trash_nouns = get_data('items').trash_nouns

    if Script.running?('bescort')
      echo 'WAITING FOR BESCORT TO FINISH'
      pause 1 while Script.running?('bescort')
    end

    if Room.current.id.nil?
      DRC.message("The script doesn't know what room it's in!  Manually move one room away and return, then everything should resume automatically!")
      pause 1 while Room.current.id.nil?
    end

    setup_town_data
    validate_requirements(args)
    be_outside_caravan
    @time_to_end = Time.now + 60 * @duration.to_i if @duration

    bput("open my #{@contract_container}", 'You open', 'That is already', 'You can.t')
    @equipment_manager.empty_hands

    if args.destination
      unless caravan_exists?
        DRC.message("No caravan found.  Call ;trade without a destination, or grab a caravan manually")
        exit
      end
      DRC.message("Taking the caravan directly to room #{args.destination}")
      take_caravan_to(args.destination.to_i)
      exit
    elsif args.outpost
      unless caravan_exists?
        DRC.message("No caravan found.  Call ;trade without a destination, or grab a caravan manually")
        exit
      end
      town_dest = find_town_from_arg(args.town_name)
      unless town_dest
        DRC.message('TOWN NOT FOUND OR NOT SUPPORTED.  CURRENTLY SUPPORTS ZOLUREN, THERENGIA, ILITHI, FORFEDHAR ONLY')
        exit
      end
      @current_caravan_destination = outpost_from_name(town_dest)
      echo "Taking the caravan directly to #{town_dest}'s trade outpost"
      do_lead_from
      do_lead_to
      take_caravan_to(@current_caravan_destination)
      exit
    else
      start_up
    end
  end

  def find_town_from_arg(town_arg)
    all_towns = ['Wolf Clan', 'Tiger Clan', 'Crossing', 'Arthe Dale', 'Stone Clan', 'Dirge', 'Leth Deriel',
                 'Shard', "Fayrin's Rest", 'Steelclaw Clan', 'Darkling Wood',
                 'Ain Ghazal', 'Boar Clan', 'Hibarnhvidar', "Raven's Point",
                 'Riverhaven', "Muspar'i", 'Therenborough', 'Hvaral', 'Fornsted', 'Langenfirth']
    all_towns.find { |town_data| town_data.split.first.casecmp(town_arg).zero? }
  end

  def validate_requirements(args) # warnings and errors for items you may be missing
    unless @trading_towns.any? { |town, _data| town == @settings.hometown } || XMLData.room_title.include?('Interior')
      echo 'Make sure you set your hometown to a town in-province!'
      echo 'This will also determine where you check to go hunting!'
      exit
    end
    unless exists?('feedbag') || args.destination
      echo 'You need a feedbag to use this script. Buy it from the Trader Shop in the guild, or ask another Trader for access'
      exit
    end
    unless exists?(@contract_container)
      echo 'No contract container found. Define it in your settings as trade_contract_container: Exiting.'
      exit
    end
    unless exists?(@craft_bag)
      echo "No crafting container found for storing items.  This will cause problems if you're doing Outfitting or Engineering."
      pause 2
    end
    @settings.storage_containers.each { |container| fput("open my #{container}") }
    @box = nil unless exists?(@box)
    if @caravan_training_skills.include?('Performance') && !exists?(@worn_instrument)
      echo 'NO WORN_INSTRUMENT FOUND.  REMOVING PERFORMANCE FROM TRAINING LIST.'
      wipe_skill('Performance', @walk_training_skills)
      wipe_skill('Performance', @lead_training_skills)
    end
    if @caravan_training_skills.include?('First Aid')
      unless @settings.textbook ? exists?(@settings.textbook_type) : exists?('compendium')
        echo 'NO COMPENDIUM OR TEXTBOOK FOUND.  CHECK YOUR ;FIRST-AID SETTINGS'
        wipe_skill('First Aid', @lead_training_skills)
      end
    end
  end

  def start_up # should parse contracts, check mats, handle expireds, get the caravan to a useful outpost, deliver any contracts, then begin the loop.
    if wealth(@settings.hometown) < @caravan_coins_on_hand
      room = Room.current.id
      command_caravan?('wait') if caravan_exists?
      withdraw_coins(@caravan_coins_on_hand)
      DRCT.walk_to(room)
    end
    unless caravan_exists?
      @use_stable && UserVars.last_seen_caravan['stabled'] ? get_caravan_stable : get_caravan
    end
    track_caravan
    speed_up_caravan
    if exists?('contract')
      mark_towns
      dump_expired
      check_for_emergency_delivery
      set_next_outpost
    else
      mark_towns
      @current_caravan_destination = find_closest_id('trader_outpost')
    end

    inventory = get_storage_inventory
    if @caravan_training_skills.include?('Engineering') && inventory.include?('lumber')
      get_item_from_storage_box?('balsa lumber')
      stow_item('balsa lumber')
    end
    if @caravan_training_skills.include?('Outfitting') && inventory.include?(DRC.get_noun(@outfitting_material_type))
      get_item_from_storage_box?(@outfitting_material_type)
      stow_item(@outfitting_material_type)
    end

    if @closeup
      count_materials(@outfitting_material_type) if @caravan_training_skills.include?('Outfitting')
      count_materials('balsa lumber') if @caravan_training_skills.include?('Engineering')
    else
      town_business
    end

    DRC.message("The current destination is #{@current_caravan_destination}")
    do_lead_from
    do_lead_to
    take_caravan_to(@current_caravan_destination)
    deliver_contract
    check_wounds
  end

  def speed_up_caravan
    return unless @caravan.noun == 'caravan'
    command_caravan?('go faster')
  end

  def close_out # makes sure your caravan is at an outpost, then returns it.  Future stable_handling?
    return close_out_stable if @use_stable
    take_caravan_to(find_closest_id('trader_outpost'))
    turn_in_items
    empty_storage_box
    walk_to(find_closest_id('shipment_clerk'))
    fput("return #{@caravan.noun}")
    walk_to(find_closest_id('trader_outpost'))
    bput('get my balsa lumber', 'You get', 'You are already', 'What were you')
    bput('drop my balsa lumber', 'You drop', 'What were you')
    unless should_knit?
      bput('get my burlap cloth', 'You get', 'You are already', 'What were you')
      bput('drop my burlap cloth', 'You drop', 'What were you')
    end
    fput('DUMP JUNK')
    fput('exit') if @exit
    exit
  end

  def close_out_stable
    turn_in_items
    DRC.message('Heading out to find a stable for the night')
    take_caravan_to(DRCT.tag_to_id('caravan_stable'))
    store_item_in_box('balsa lumber') if @caravan_training_skills.include?('Engineering') && DRCI.exists?('balsa lumber')
    store_item_in_box(@outfitting_material_type) if @caravan_training_skills.include?('Outfitting') && DRCI.exists?(@outfitting_material_type)
    /(\d+) (Kronars|Lirums|Dokoras) for a caravan/ =~ bput('pay', 'The cost for stabling .*')
    case bput("pay #{Regexp.last_match(1)}", 'The price for stabling and feeding .*', 'stable.+ who runs up and leads your caravan')
    when /The price for stabling and feeding/
      DRC.beep
      DRC.message('Something has gone wrong!  Put in an issue at https://github.com/rpherbig/dr-scripts/issues/new with a log of this event!')
      exit
    end

    fput('exit') if @exit
    exit
  end

  def run # Primary loop
    loop do
      walk_to(find_closest_id('trader_outpost'))
      if @closeup
        close_out unless exists?('contract')
      else
        magic_cleanup
        town_business
        wait_for_script_to_complete('buff', ['trade'])
        get_contract
      end
      walk_to(find_closest_id('trader_outpost'))
      feed_caravan
      mark_towns
      check_for_emergency_delivery unless @closeup
      set_next_outpost
      echo "Destination town is #{find_town(@current_caravan_destination)}"
      do_lead_from
      do_lead_to
      take_caravan_to(@current_caravan_destination)
      dump_expired
      deliver_contract
      pay_dues
      check_wounds
      @closeup = true if @time_to_end && Time.now > @time_to_end
    end
  end

  def closest_town
    find_town(find_closest_id('trader_outpost'))
  end

  def find_closest_id(entity, need_business = false) # finds the closest room in @town_data that matches 'entity' (ie, trader_outpost, trade_minister). 'need_business' true requires a contract to pick up or deliver there
    rooms = @town_data.to_h
                      .values
                      .select { |data| data[entity] }
                      .map    { |data| data[entity]['id'] }
    UserVars.athletics = 1
    result = sort_destinations(rooms)
    UserVars.athletics = DRSkill.getrank('Athletics')
    if need_business
      result.find do |data|
        should_go_to_town?(find_town(data))
      end
    else
      result.first
    end
  end

  def forbid_certain_transport # No-go areas.  Restored on script-end and when not leading caravans
    # DESPITE DEDICATED TRAINING, OXEN PERSIST IN FALLING OFF ROPE BRIDGES
    Room[8637].timeto.delete('8650')
    Room[8650].timeto.delete('8637')
    # AIRSHIP EXISTENCE CAUSING PROBLEMS WITH THE TIMETOS
    Room[989].timeto.delete('247')
    Room[247].timeto.delete('989')
    Room[3766].timeto['6872'] = 600.0
    Room[6872].timeto['6872'] = 600.0
  end

  def restore_certain_transport
    # THEREN ROPE BRIDGE
    Room[8637].timeto['8650'] = 180.0
    Room[8650].timeto['8637'] = 180.0
    # AIRSHIP
    Room[989].timeto['247'] = 600.0
    Room[247].timeto['989'] = 600.0
    Room[3766].timeto['6872'] = 799.0
    Room[6872].timeto['6872'] = 799.0
  end

  def setup_town_data # builds @trading_towns from town_data
    # inconvenient_contract_threshold is how many awkward contracts (@inconvenient_towns) to hold before biting the bullet and starting to prioritize them
    # the number assigned to each town is how many contracts to that particular town should force a trip in that direction.
    case find_province
    when 'Zoluren'
      province_towns = { 'Wolf Clan' => 2, 'Tiger Clan' => 2, 'Crossing' => 2, 'Arthe Dale' => 2, 'Stone Clan' => 2, 'Dirge' => 2, 'Leth Deriel' => 3 }
      @inconvenient_contract_threshold = 4
    when 'Ilithi'
      province_towns = { 'Shard' => 2, 'Steelclaw Clan' => 2, "Fayrin's Rest" => 2, 'Darkling Wood' => 2 }
      @inconvenient_contract_threshold = 5
    when 'Forfedhar'
      province_towns = { 'Hibarnhvidar' => 5, 'Boar Clan' => 5, "Raven's Point" => 1, 'Ain Ghazal' => 2 }
      @inconvenient_contract_threshold = 5
    when 'Therengia'
      province_towns = { 'Riverhaven' => 2, 'Hvaral' => 2, 'Fornsted' => 2, 'Langenfirth' => 2, "Muspar'i" => 3, 'Therenborough' => 2 }
      @inconvenient_contract_threshold = 3
    end
    province_towns.each do |town_name, threshold|
      @trading_towns[town_name] = @town_data[town_name]
      @trading_towns[town_name]['contracts_to'] = @trading_towns[town_name]['contracts_from'] = 0
      @trading_towns[town_name]['contract_threshold'] = threshold
    end
    @town_data = @trading_towns
  end

  def find_province
    case closest_town
    when 'Wolf Clan', 'Tiger Clan', 'Crossing', 'Arthe Dale', 'Stone Clan', 'Dirge', 'Leth Deriel'
      @province = 'Zoluren'
    when 'Shard', "Fayrin's Rest", 'Steelclaw Clan', 'Darkling Wood'
      @province = 'Ilithi'
    when 'Ain Ghazal', 'Boar Clan', 'Hibarnhvidar', "Raven's Point"
      @province = 'Forfedhar'
    when 'Riverhaven', 'Hvaral', 'Fornsted', 'Langenfirth', "Muspar'i", 'Therenborough'
      @province = 'Therengia'
    end
  end

  def mark_towns # records some information about contracts to and from towns
    setup_town_data
    gather_contracts
    @held_contracts.each do |contract|
      @trading_towns[contract.origin_town]['contracts_from'] += 1
      @trading_towns[contract.destination_town]['contracts_to'] += 1
    end
    @force_contract_from.each do |town|
      @trading_towns[town]['contracts_from'] += 1
    end
  end

  def set_next_outpost # main method that determines the next outpost you're trying to reach
    forbid_certain_transport
    if @emergency_delivery_town
      @current_caravan_destination = closer_to_emergency_town
      echo "The next outpost on the way to #{@emergency_delivery_town} is #{find_town(@current_caravan_destination)}"
      @emergency_delivery_town = nil
    else
      @current_caravan_destination = find_closest_id('trader_outpost', true)
    end
    if @current_caravan_destination.zero? || @current_caravan_destination.nil?
      DRC.message('The script has encountered an error! Please put in an issue at https://github.com/rpherbig/dr-scripts/issues')
      DRC.message("Current Room is #{Room.current.id}, closest town is #{find_closest_id('trader_outpost', true)}, and emergency_town is #{@emergency_delivery_town}, if any.")
    end
    restore_certain_transport
  end

  def check_for_emergency_delivery # go towards a town if you have a certain amount of business there
    amount = 0
    forbid_certain_transport
    @trading_towns.select { |name, _info| @inconvenient_towns.include?(name) }
                  .each   { |_name, info| amount += info['contracts_to'] }

    if amount >= @inconvenient_contract_threshold
      @emergency_delivery_town = @trading_towns.sort_by { |_name, info| time_to_room(Room.current.id, info['trader_outpost']['id']) }
                                               .max_by  { |_name, info| info['contracts_to'] }.first
      echo "Emergency delivery needed to #{@emergency_delivery_town}"
    else
      @trading_towns.find do |name, info|
        if info['contracts_to'] - info['contracts_from'] >= info['contract_threshold']
          @emergency_delivery_town = name
          echo "Emergency delivery needed to #{@emergency_delivery_town}"
        end
      end
    end
    restore_certain_transport
  end

  def closer_to_emergency_town # from the set of all outposts closer than you to the emergency_town, return the one closest to you that you have business in
    return Room.current.id if outpost_from_name(@emergency_delivery_town) == Room.current.id
    rooms = @trading_towns.to_h.values.select { |data| data['trader_outpost'] }
                          .map { |data| data['trader_outpost']['id'] }
    target_list = rooms.collect(&:to_i)
    _previous, shortest_distances = Map.dijkstra(outpost_from_name(@emergency_delivery_town))
    target_list.delete_if { |room_num| shortest_distances[room_num].nil? && room_num == Room.current.id }
    target_list.each { |room_num| echo "Distance from emergency_town to #{room_num} : #{shortest_distances[room_num]} and distance to current room is #{shortest_distances[Room.current.id]}" } if debugging?
    target_list.delete_if { |room_num| shortest_distances[room_num] > shortest_distances[Room.current.id] + 0.5 }
    target_list = DRCT.sort_destinations(target_list)
    target_room = target_list.find do |room_num|
      should_go_to_town?(find_town(room_num))
    end
    target_room ? target_room : outpost_from_name(@emergency_delivery_town)
  end

  def town_lead_name(town_name) # very different lead command parsing for some town names
    town_map = { 'Leth Deriel' => 'Leth', 'Darkling Wood' => 'Darkling', "Raven's Point" => 'Raven', 'LethFerry' => 'Crossing' }
    town_map[town_name] ? town_map[town_name] : town_name
  end

  def do_lead_from # you must escape the gravity of certain towns for your caravan to break orbit and lead you away
    return unless @caravan.noun == 'caravan'
    nearest_town = closest_town
    destination_town = find_town(@current_caravan_destination)
    echo "destination is #{destination_town}" if debugging?
    echo "nearest_town is #{nearest_town}" if debugging?
    return if nearest_town == destination_town

    case nearest_town
    when 'Leth Deriel'
      take_caravan_to(1968) unless lead_caravan_to?('LethFerry') # lead the caravan to the Ferry
      take_caravan_to(895) # walk it across the Ferry, then proceed.
    when 'Boar Clan'
      lead_caravan_to?('Hibarnhvidar')
    when 'Ain Ghazal'
      if destination_town == 'Boar Clan'
        take_caravan_to(3986) unless lead_caravan_to?('Hibarnhvidar')
      else
        take_caravan_to(3986) unless lead_caravan_to?(destination_town)
      end
    when "Raven's Point"
      if destination_town == 'Boar Clan'
        take_caravan_to(4452) unless lead_caravan_to?('Hibarnhvidar')
      else
        take_caravan_to(4452) unless lead_caravan_to?(destination_town)
      end
    when 'Hibarnhvidar'
      if destination_town == 'Boar Clan'
        unless lead_caravan_to?('Boar Clan')
          lead_caravan_to?('Hibarnhvidar')
          take_caravan_to(3991)
        end
      else
        take_caravan_to(3943) unless lead_caravan_to?(destination_town)
      end
    when "Muspar'i"
      destination_town == 'Hvaral' ? take_caravan_to(3751) : take_caravan_to(3764)
    when 'Riverhaven'
      take_caravan_to(3339) unless destination_town == 'Langenfirth'
    when 'Langenfirth'
      take_caravan_to(3339) unless destination_town == 'Riverhaven' || lead_caravan_to?('Therenborough')
    when 'Hvaral'
      take_caravan_to(3764) unless destination_town == "Muspar'i" || lead_caravan_to?('Fornsted')
    when 'Fornsted'
      take_caravan_to(3706) if ['Hvaral', "Muspar'i"].include?(destination_town) && !lead_caravan_to?('Hvaral')
    when 'Therenborough'
      take_caravan_to(3234) if %w[Langenfirth Riverhaven].include?(destination_town) && !lead_caravan_to?('Langenfirth')
    end
  end

  def do_lead_to # handles final lead-to approach to certain towns AFTER escaping do_lead_from
    echo "do_lead_to #{@current_caravan_destination}" if debugging?
    return unless @caravan.noun == 'caravan'
    destination_town = find_town(@current_caravan_destination)
    nearest_town = closest_town
    echo "destination is #{destination_town}" if debugging?
    echo "nearest_town is #{nearest_town}" if debugging?
    return lead_caravan_to?(destination_town) if nearest_town == destination_town

    case destination_town
    when 'Leth Deriel'
      if nearest_town == destination_town
        lead_caravan_to?(destination_town)
      else
        lead_caravan_to?('Crossing') unless nearest_town == 'Crossing'
        take_caravan_to(1904) # then to the ferry
        lead_caravan_to?(destination_town) # then to Leth
      end
    when 'Boar Clan'
      if ["Raven's Point", 'Ain Ghazal'].include?(nearest_town)
        take_caravan_to(3984) unless lead_caravan_to?('Hibarnhvidar')
        take_caravan_to(3903) unless lead_caravan_to?('Hibarnhvidar')
        lead_caravan_to?('Boar Clan')
      elsif nearest_town == 'Hibarnhvidar'
        take_caravan_to(3903) unless lead_caravan_to?('Boar Clan')
        lead_caravan_to?('Boar Clan')
      end
    when "Raven's Point", 'Ain Ghazal'
      if nearest_town == 'Hibarnhvidar'
        take_caravan_to(3943) unless lead_caravan_to?(destination_town)
        lead_caravan_to?(destination_town) unless closest_town == destination_town
      end
    when "Muspar'i"
      if %w[Therenborough Langenfirth].include?(nearest_town)
        lead_caravan_to?('Therenborough') if nearest_town == 'Langenfirth'
        take_caravan_to(3706)
        lead_caravan_to?('Hvaral')
      elsif nearest_town == 'Fornsted'
        lead_caravan_to?('Hvaral')
      end
    when 'Hvaral'
      if %w[Therenborough Langenfirth].include?(nearest_town)
        lead_caravan_to?('Therenborough') if nearest_town == 'Langenfirth'
        take_caravan_to(3706)
        lead_caravan_to?('Hvaral')
      elsif nearest_town == 'Fornsted'
        lead_caravan_to?('Hvaral')
      end
    when 'Fornsted'
      case nearest_town
      when 'Fornsted', 'Hvaral'
        lead_caravan_to?('Fornsted')
      when 'Langenfirth'
        lead_caravan_to?('Therenborough')
      end
    when 'Therenborough'
      lead_caravan_to?('Therenborough') if nearest_town == 'Langenfirth'
      lead_caravan_to?('Fornsted') if nearest_town == 'Hvaral'
    when 'Langenfirth', 'Riverhaven'
      if %w[Hvaral Fornsted].include?(nearest_town)
        lead_caravan_to?('Fornsted')
        take_caravan_to(3234)
        lead_caravan_to?('Langenfirth')
      elsif %w[Therenborough Langenfirth].include?(nearest_town)
        lead_caravan_to?('Langenfirth')
      end
    else
      lead_caravan_to?(destination_town)
    end
  end

  def lead_caravan_to?(town_name) # Primary method for being led by or riding in a caravan
    return false if @no_lead_towns.include?(town_name)
    track_caravan
    return true if Room.current.id == outpost_from_name(town_name)
    @caravan_being_led = true
    return false unless command_caravan?("lead to #{town_lead_name(town_name)}")
    save_caravan_position(outpost_from_name(town_name))
    be_inside_caravan
    pause 2
    until Flags['lead-arrived'] || Flags['lead-failed'] # main wait loop while training happens
      lead_training
      pause 1.5
    end

    training_cleanup

    if Flags['lead-failed']
      Flags.reset('lead-failed')
      Flags.reset('lead-arrived')
      false
    else
      perform_outside_move(@outside_exits[town_name]) if @outside_exits[town_name]
      Flags.reset('lead-arrived')
      true
    end
  end

  # a rare lich crash occurs when leaving a moving caravan and trying to get the room_id. Leaving the room manually prevents it
  def perform_outside_move(room_exits)
    return unless @caravan_interior
    echo 'perform_outside_move' if debugging?
    be_outside_caravan
    DRC.fix_standing
    Flags.reset('caravan-arrived')
    if room_exits.is_a?(String)
      move room_exits
    else
      command_caravan?('wait')
      room_exits.each do |r_exit|
        move r_exit
      end
    end
    wait_for_caravan(1)
    save_caravan_position(Room.current.id)
  end

  def be_inside_caravan # call whenever you need to be inside the caravan
    return unless @caravan_interior
    return unless @caravan_being_led
    return if @no_ride_rooms.any? { |name| XMLData.room_title.include?(name) } # Don't do this on ferrys - you can't tell when you've arrived.
    track_caravan
    bput("go #{@caravan.adjective} #{@caravan.noun}", 'You open the door')
  end

  def be_outside_caravan # call whenever you need to be outside the caravan
    return unless XMLData.room_title.include?('Interior')
    waitrt?
    move('go door')
    pause 1
  end

  def track_caravan # requires caravan to be in-room with you.
    return false unless caravan_exists?
    unless caravan_check?
      pause 2
      find_timer = Time.now
      echo 'CARAVAN NOT PRESENT IN THE ROOM.  SCRIPT WILL EXIT IN 2 MINUTES UNLESS YOU FIND THE CARAVAN' unless caravan_check?
      pause 5 until caravan_check? || Time.now - find_timer > 120
    end
    Flags.reset('caravan-arrived')
  end

  def recall_caravan? # gets information about your caravan. Also returns true if it's in the room with you.
    return true if @last_seen_caravan[0] == Room.current.id && Time.now - @last_seen_caravan[1] < 3
    recall_messages = [
      /^You seem to recall that you left your (?<description>.*) (?<name>.*) right behind you/,
      /^You don't recall where you left your caravan\./,
      /^You don't recall having a caravan\./,
      /^You are far too occupied/,
      /^You (seem to )?recall (that )?your (?<description>.*) (?<name>.*)/
    ]
    response = bput('recall caravan', recall_messages)
    echo("Response: #{response}") if debugging?
    case response
    when /You don't recall where you left your caravan/, /You don't recall having a caravan/
      echo('No caravan found') if debugging?
      false
    when /You seem to recall that you left your (?<description>.*) (?<name>.*) right behind you/
      /You seem to recall that you left your (?<description>.*) (?<name>.*) right behind you/ =~ response
      @caravan.noun ||= name
      @caravan.adjective ||= description.split.first
      @last_seen_caravan = [Room.current.id, Time.now]
      true
    when /You (seem to )?recall that your (?<description>.*) (?<name>.*)/
      /You recall that your (?<description>.*) (?<name>.*)/ =~ response
      @caravan.noun ||= name
      @caravan.adjective ||= description.split.first
      false
    when /You are far too occupied/
      DRC.retreat
      recall_caravan?
    else
      false
    end
  end

  def find_town(room_id) # takes a room_id and returns a town_name if find_value? finds it in a town's data.
    @town_data.to_h.find { |_name, data| find_value?(data, room_id) }.first.to_s
  end

  def find_value?(towninfo, room_id)
    return false unless towninfo['trader_outpost']
    towninfo['shipment_clerk']['id'] == room_id || towninfo['trade_minister']['id'] == room_id || towninfo['trader_outpost']['id'] == room_id
  end

  def outpost_from_name(town_name) # gives the trader_outpost room_id from a specific town name
    @trading_towns[town_name]['trader_outpost']['id'].to_i
  end

  def gather_contracts # reads every contract you have and adds their data to @held_contracts for use elsewhere
    echo 'gathering contracts' if debugging?
    @held_contracts = []
    contracts = find_contracts(@contract_container)
    (0..contracts.length - 1).each do |ord|
      @held_contracts.push(parse_contract($ORDINALS[ord]))
    end
  end

  def parse_contract(ordinal = 'first') # parses an individual contract based on an ordinal
    destination_re = /^ The guild office at (?:The )?(?<destination>.*) requires .*/
    payment_re = /^You estimate these goods are currently worth (.*) (Kronars|Dokoras|Lirums) on delivery\./
    origin_re = /^ Trading Contract Issued by:  (?:The )?(?<origin>.*)/
    contract = OpenStruct.new
    contract.presented = true
    contract.expired = false
    fput("read my #{ordinal} contract")
    while line = get
      if line =~ destination_re
        contract.destination_town = line.match(destination_re).captures.first
        contract.destination_outpost = @town_data[contract.destination_town]['trader_outpost']['id']
        contract.destination_clerk = @town_data[contract.destination_town]['shipment_clerk']['id']
        contract.destination_minister = @town_data[contract.destination_town]['trade_minister']['id']
      elsif line =~ payment_re
        # This is the last line of the contract so break when finished
        contract.payment, contract.currency = line.match(payment_re).captures
        break
      elsif line =~ origin_re
        contract.origin_town = line.match(origin_re).captures.first
        contract.origin_clerk = @town_data[contract.origin_town]['shipment_clerk']['id']
        contract.origin_minister = @town_data[contract.origin_town]['trade_minister']['id']
        contract.origin_outpost = @town_data[contract.origin_town]['trader_outpost']['id']
      elsif line =~ /This contract has yet to be/
        contract.presented = false
      elsif line =~ /The contract is now useless since it has expired\./
        contract.expired = true
        break
      end
    end
    if debugging?
      echo "Contract origin: #{contract.origin_town}"
      echo "Contract origin clerk room: #{contract.origin_clerk}"
      echo "Contract origin minister room: #{contract.origin_minister}"
      echo "Contract destination town: #{contract.destination_town}"
      echo "Contracted presented to clerk? #{contract.presented}"
    end
    contract
  end

  def find_contracts(container) # returns an array of the contracts in the container
    result = DRC.bput("look in my #{container}", 'That is closed', 'you see .*', 'While it\'s closed', 'I could not find', 'There is nothing')
    case result
    when 'That is closed'
      fput("open my #{container}")
      return find_contracts(container)
    end
    text = result.match(/you see (.*)\.$/).to_a[1]
    DRC.list_to_array(text).select { |item| item.include?('contract') }
  end

  def count_grass # sets @current_grass_count of grass in feedbag
    result = DRC.bput('look in my feedbag', 'That is closed', 'you see .*', 'While it\'s closed', 'I could not find', 'There is nothing', 'Maybe if you')
    case result
    when 'That is closed', 'Maybe if you'
      fput('open my feedbag')
      return count_grass
    when 'I could not find'
      echo('No feedbag.  Exiting.')
      exit
    end

    text = result.match(/you see (.*)\.$/).to_a[1]
    @current_grass_count = DRC.list_to_array(text).select { |item| item.include?('some grass') }.length
  end

  def forage_grass # periodically forages for grass if below 70
    return if @current_grass_count > 70 || @training_token
    return if @no_forage_rooms.any? { |roomcheck| XMLData.room_title.include?(roomcheck) }
    @cooldown_timers['Grass'] ||= Time.now - 10
    return if Time.now - @cooldown_timers['Grass'] < 10
    be_outside_caravan
    if forage?('grass')
      bput('put my grass in my feedbag', 'You put', 'What were you')
      @current_grass_count += 6
    end
    @cooldown_timers['Grass'] = Time.now
  end

  def forage?(item) # common's forage loops.  Can't do that in rooms where there might be nothing, so we use this
    snapshot = "#{right_hand}#{left_hand}"
    bput("forage #{item}", 'Roundtime', 'The room is too cluttered to find anything here', 'You really need to have at least one hand free to forage properly', 'You survey the area and realize that any foraging efforts would be futile')
    snapshot != "#{right_hand}#{left_hand}"
  end

  def compute_path(destination)
    echo "computing path #{destination}" if debugging?
    Script.pause('skill-recorder') if Script.running?('skill-recorder')
    UserVars.athletics = 1
    previous, _shortest_paths = Map.dijkstra(Room.current.id, destination)
    UserVars.athletics = DRSkill.getrank('Athletics')
    path = [destination]
    path.push(previous[path[-1]]) until previous[path[-1]].nil?
    Script.unpause('skill-recorder') if Script.running?('skill-recorder')
    path.reverse
  end

  def time_to_room(origin, destination)
    _previous, shortest_paths = Map.dijkstra(origin, destination)
    shortest_paths[destination]
  end

  def step(dir) # takes normal steps and handles stringprocs
    echo "step dir: #{dir}" if debugging?
    case dir
    when String
      move(dir)
    when Proc, StringProc
      dir.call
    end
  end

  def handle_special_room?(dir) # handles very specific rooms (bescort rooms currently) - allows training on ferries.
    case dir
    when StringProc
      if dir.inspect.include?('ferry') || dir.inspect.include?('barge')
        ferry_run
        true
      elsif dir.inspect.include?('gondola')
        ride_gondola
        true
      elsif dir.inspect.include?('iceroad')
        run_iceroad
        true
      else
        false
      end
    when String
      if Room.current.id == 464 && dir == 'north' # Riverhaven Pier is busted for single-room travel
        Flags.reset('caravan-arrived')
        step('north')
        wait_for_caravan
        step('west')
        wait_for_caravan
        ferry_run
        true
      elsif Room.current.id == 4056 # Weird stringproc rooms in Forf
        Flags.reset('caravan-arrived')
        step('northwest')
        true
      elsif Room.current.id == 4059 # Weird stringproc rooms in Forf
        Flags.reset('caravan-arrived')
        step('southeast')
        true
      else
        false
      end
    else
      false
    end
  end

  def run_iceroad
    # You shouldn't actually get into this section unless you're manually running to certain roomids
    # For now, just leading to a nearby city.
    case Room.current.id
    when 4430 # shardside
      lead_caravan_to?('Hibarnhvidar')
    when 4366 # hibside
      lead_caravan_to?("Raven's Point")
    end
  end

  def ride_gondola
    mode = 'south' if Room.current.id == 2249
    mode = 'north' if Room.current.id == 2904
    Flags.add('trade-gondola-arrive', 'The gondola stops on the platform and the door silently swings open', 'With a soft bump, the gondola comes to a stop at its destination')
    @caravan_being_led = true
    wipe_bescort_skills
    Flags.reset('caravan-arrived')
    case bput('go gondola', 'There is no wooden gondola here', 'Gondola, Cab')
    when /no wooden gondola here/i
      waitfor 'The gondola stops on the platform and the door silently swings open'
      until Flags['trade-gondola-arrive']
        pause 1.5
        lead_training
      end
    when /Gondola, Cab/
      wait_for_caravan
      move mode
    end
    until Flags['trade-gondola-arrive']
      pause 1.5
      lead_training
    end
    wait_for_caravan(3)
    move 'out'
    training_cleanup
    restore_bescort_skills
    @caravan_being_led = false
  end

  def ferry_run
    echo 'ferry_run' if debugging?
    case Room.current.id
    when 3986
      town = 'hibarnhvidar'
      mode = 'ferry1'
    when 11_027
      town = 'ainghazal'
      mode = 'ferry1'
    when 1904
      town = 'crossing'
      mode = 'ferry'
    when 957
      town = 'leth'
      mode = 'ferry'
    when 466, 50_948, 3434
      town = ''
      mode = 'lang_barge'
    when 3766
      town = 'hvaral'
      town2 = 'muspari'
      mode = 'sandbarge'
    when 6872
      town = 'muspari'
      town2 = 'hvaral'
      mode = 'sandbarge'
    end
    training_cleanup
    town2 ? start_script('bescort', [mode, town, town2]) : start_script('bescort', [mode, town])
    wait_to_arrive
    if mode == 'lang_barge' && [466, 50_948].include?(Room.current.id) # Riverhaven pier is screwed up forever, but this works
      Flags.reset('caravan-arrived')
      wait_for_caravan(3)
      step('east')
      wait_for_caravan
      step('south')
      wait_for_caravan
      step('east')
      wait_for_caravan
    end
  end

  def wait_to_arrive
    @caravan_being_led = true
    wipe_bescort_skills
    Flags.reset('trade-bescort')
    Flags.reset('trade-ferry-arrival')
    Flags.reset('trade-barge')
    while Script.running?('bescort')
      pause 1.5
      if Flags['trade-bescort']
        training_cleanup
        pause while Script.running?('bescort')
        break
      end
      lead_training
      if Flags['trade-barge']
        command_caravan?('follow')
        Flags.reset('trade-barge')
      end
    end
    training_cleanup
    restore_bescort_skills
    @caravan_being_led = false
  end

  def save_caravan_position(room)
    return unless caravan_check?
    @last_seen_caravan = [room, Time.now]
    UserVars.last_seen_caravan = { 'room' => room, 'last_seen' => Time.now, 'stabled' => Room.current.title.include?(/Stable|Barn/) }
  end

  def return_to_caravan
    return if Room.current.id == @last_seen_caravan[0]
    walk_to(@last_seen_caravan[0])
  end

  def wipe_bescort_skills
    wipe_skill('Outdoorsmanship', @lead_training_skills) if @caravan_training_skills['Outdoorsmanship']
    wipe_skill('Perception', @lead_training_skills) if @caravan_training_skills['Perception']
    wipe_skill('Athletics', @lead_training_skills) if @caravan_training_skills['Athletics']
  end

  def restore_bescort_skills
    restore_skill('Outdoorsmanship', @caravan_training_skills['Outdoorsmanship'], @lead_training_skills) if @caravan_training_skills['Outdoorsmanship']
    restore_skill('Perception', @caravan_training_skills['Outdoorsmanship'], @lead_training_skills) if @caravan_training_skills['Perception']
    restore_skill('Athletics', @caravan_training_skills['Outdoorsmanship'], @lead_training_skills) if @caravan_training_skills['Athletics']
  end

  def get_next_dir(path)
    Room.current.wayto[path[path.index(Room.current.id) + 1].to_s]
  end

  def take_caravan_to(room_id) # primary method for leading your caravan to a destination step-by-step.
    @caravan_being_led = false
    be_outside_caravan
    track_caravan
    return if Room.current.id == room_id
    forbid_certain_transport
    echo "destination is #{room_id}" if debugging?
    command_caravan?('follow')
    path = compute_path(room_id)
    echo "path: #{path}" if debugging?
    pause 0.2 until Flags['caravan-arrived'] || caravan_check?(false)
    until Room.current.id == room_id
      dir = get_next_dir(path)
      path = compute_path(room_id) if dir.nil?
      if handle_special_room?(dir)
        Flags.reset('caravan-arrived')
        wait_for_caravan(3)
      else
        step(dir)
        walk_training
        wait_for_caravan
        @step_toggle += 1
      end
      echo 'Caravan arrival detected' if debugging?
    end
    save_caravan_position(Room.current.id)
    command_caravan?('wait')
    training_cleanup
    restore_certain_transport
  end

  def wait_for_caravan(wait_time = 6) # The wait time is how long to wait until doing noisy RECALL CARAVANs.  A grace period for the caravan to arrive quietly.
    time_waiting = Time.now
    return if @caravan_being_led && !Script.running?('bescort') && caravan_present?
    return if @last_seen_caravan[0] == Room.current.id && (Time.now - @last_seen_caravan[1]) < 10
    until Flags['caravan-arrived']
      pause 0.2
      break if Time.now - time_waiting > wait_time && caravan_check?
    end
    Flags.reset('caravan-arrived')
  end

  def command_caravan?(command)
    pause 1
    case command
    when 'follow'
      follow_messages = [
        'You grab hold of your .* harness and make it follow.',
        'You pass on the order to follow to your driver, who makes sure your .* does your bidding.'
      ]
      bput("tell #{@caravan.adjective} #{@caravan.noun} to follow", follow_messages)
      return true
    when 'wait'
      wait_messages = [
        'You pass on the order to wait to your driver, who makes sure your .* does your bidding',
        'You grab hold of your .* harness and make it wait.'
      ]
      bput("tell #{@caravan.adjective} #{@caravan.noun} to wait", wait_messages)
      return true
    when /lead/
      lead_success = [
        'You pass on the order to lead to your driver'
      ]
      lead_fail = [
        'but turns back and says',
        'The driver of the .* looks at you confused and says'
      ]
      bput("tell #{@caravan.adjective} #{@caravan.noun} to #{command}", lead_success + lead_fail) == 'You pass on the order to lead to your driver' ? true : false
    when 'go faster'
      pause 0.5 until bput("tell #{@caravan.adjective} #{@caravan.noun} to #{command}", 'speed up the pace,', 'speed up the pace\.') == 'speed up the pace,'
      true
    else
      false
    end
  end

  def should_go_to_town?(town_name) # is there any reason at all to visit this town's outpost?
    if @closeup
      return true if @trading_towns[town_name]['contracts_to'] > 0
    else
      return true if @trading_towns[town_name]['contracts_to'] > 0 || @trading_towns[town_name]['contracts_from'].zero?
    end
    false
  end

  def get_contract
    minister_id = find_closest_id('trade_minister')
    return if @trading_towns[find_town(minister_id)]['contracts_from'] > 0
    echo "Getting a new contract from room #{minister_id}" if debugging?
    walk_to(minister_id)
    minister_messages = [
      'The minister plucks a contract from the hands',
      'The minister reminds you that you still owe .*',
      'You still have another contract'
    ]
    response = bput('ask minister for contract', minister_messages)
    case response
    when /The minister reminds you/
      /The minister reminds you that you still owe (?<dues_amt>.*) (?<dues_currency>Kronars|Lirums|Dokoras) in dues to (?:The )?(?<outpost>.*) and asks that you pay the clerk before s?he issues you a new contract\./ =~ response
      echo "Need to pay #{dues_amt} #{dues_currency} to #{outpost}" if debugging?
      if wealth(@settings.hometown) < dues_amt.to_i
        # If you've run out of money, it will run to your hometown to get more.  Potential to pull from drinfomon for nearest savings account?
        room = Room.current.id
        ensure_copper_on_hand(@caravan_coins_on_hand + dues_amt.to_i, @settings)
        walk_to(room)
      end
      pay_dues
      get_contract
    when /You still have another contract/
      @force_contract_from.push(find_town(minister_id)) unless @trading_towns['contracts_from'] # force_contract_from handles contracts that have somehow been lost.  The minister won't give another until it would have expired
    else
      @force_contract_from - [find_town(minister_id)] if @force_contract_from.include?(find_town(minister_id))
      load_caravan
    end
  end

  def deliver_contract
    clerk_id = find_closest_id('shipment_clerk')
    echo 'Delivering Contracts'
    walk_to(clerk_id)
    clerk_messages = [
      'What have you done with the goods',
      '^The \w+ clerk finds everything in order with your merchandise',
      'The shipment clerk shakes his head'
    ]
    current_town = find_town(Room.current.id).split.first
    until bput("get my #{current_town} contract from my #{@contract_container}", 'You get', 'What were you') == 'What were you'
      case bput('give my contract to clerk', clerk_messages)
      when 'What have you done with the goods'
        # Potential to do an immediate parse_contract and force_contract_from that town to 1 so you don't go back there for nothing.
        dispose_trash('contract')
      end
    end
  end

  def pay_dues
    clerk_id = find_closest_id('shipment_clerk')
    echo "Paying dues at clerk_room: #{clerk_id}" if debugging?
    clerk_messages = [
      /^You don't have any coins on you to pay dues\./,
      /^You count out some coins, and the clerk notes that your dues are settled\./,
      /^You count out some coins, and the clerk notes that your dues are now (.*)\./,
      /^The clerk says, "You do not owe dues, .*!"/
    ]
    walk_to(clerk_id)
    bput('pay clerk', clerk_messages)
  end

  def get_caravan
    clerk_id = find_closest_id('shipment_clerk')
    walk_to(clerk_id)
    if bput('rent caravan', 'You want to upgrade from a', 'The clerk nods and says', 'The clerk looks at you and says,') == 'The clerk looks at you and says,'
      return get_caravan_stable
    end
    trader_outpost = find_closest_id('trader_outpost')
    walk_to(trader_outpost)
    recall_caravan?
  end

  def get_caravan_stable
    DRC.message('Going to find your caravan in the last-seen or nearest stable.')
    #make sure you have the money
    if UserVars.last_seen_caravan['stabled']
      DRCT.walk_to(UserVars.last_seen_caravan['room'])
    else
      DRCT.walk_to('stable')
    end
    case bput('RETURN CARAVAN', 'The clerk looks at you funny', 'Please rephrase', 'stable.+ who hurries off to a stall', 'You don\'t have anything', 'Your caravan is not at this')
    when 'Please rephrase', 'The clerk looks at you funny'
      UserVars.last_seen_caravan['stabled'] = false
      get_caravan_stable
    when /stable.+ who hurries off to a stall/
      return
    else
      DRC.beep
      DRC.message('Could not find your stabled caravan.  Most caravan stables should be tagged so that ;go2 stable will go to the nearest one, but you\'ll have to find it on your own and restart the script.')
      exit
    end
  end

  def feed_caravan # feeds your caravan from a feedbag.
    bput('open my feedbag', 'You open', 'What were', 'That is already')
    feed_messages = [
      'The driver takes the feedbag from you',
      'You offer the .* feedbag to the caravan driver',
      'The .* sniffs disinterestedly at your .* feedbag',
      'The .* sticks its nose into your feedbag and munches away happily'
    ]
    @equipment_manager.empty_hands
    @worn_feedbag = DRC.bput('remove my feedbag', 'You remove', 'You aren.t wearing that', 'Remove what') == 'You remove' if @worn_feedbag
    bput('get my feedbag', 'You get') unless @worn_feedbag
    @current_grass_count -= 1 if ['The driver takes the feedbag from you', 'The .* sticks its nose into your feedbag and munches away happily'].include?(DRC.bput("give #{@caravan.adjective} #{@caravan.noun}", feed_messages))
    @worn_feedbag ? DRC.bput('wear feedbag', 'You attach') :  DRC.bput('stow my feedbag', 'You put')
  end

  def load_caravan
    clerk_id = find_closest_id('shipment_clerk')
    echo "Presenting contract to clerk in room: #{clerk_id}" if debugging?
    walk_to(clerk_id)
    give_clerk
  end

  def caravan_check?(stationary = true) # The traders' guild hands out identical caravans
    return false unless caravan_present?
    pause 1.5 unless stationary
    return true if Flags['caravan-arrived']
    recall_caravan?
  end

  def caravan_present? # is there a caravan that LOOKS like yours in the room?
    return false unless @caravan.adjective
    return false unless @caravan.noun
    @caravan_room_descriptions[@caravan.adjective] ||= @caravan.adjective
    DRRoom.room_objs.find { |obj| obj =~ /#{@caravan_room_descriptions[@caravan.adjective]}/ && obj =~ /#{@caravan.noun}/ }
  end

  def caravan_exists? # do you have a caravan at all?
    recall_caravan? unless @caravan.adjective && @caravan.noun
    @caravan.adjective && @caravan.noun
  end

  def dump_expired # checks for expired contracts, and gets rid of them and the matching crate. TODO: recheck contracts before tossing them.  Hasn't broken yet, but...
    return unless @held_contracts
    @held_contracts.each_with_index do |contract, index|
      next unless contract['expired']
      find_crates(contract.origin_town)
      bput("get my #{$ORDINALS[index]} contract from #{@contract_container}", 'You get')
      bput('drop my contract', 'You drop')
      gather_contracts
      return dump_expired
    end
  end

  def dump_crate(ordinal) # removes a crate
    bput("push #{ordinal} sturdy crate", 'You grab onto')
    bput('pull sturdy crate', 'You begin to pull')
    bput('pull sturdy crate', 'You begin to pull', 'You continue to pull')
  end

  def find_crates(origin_town) # handles finding the crate that matches the expired contract.
    echo "find_crates from #{origin_town}" if debugging?
    result = DRC.bput("look #{@caravan.adjective} #{@caravan.noun}", 'You tell the driver', 'I could not find', 'There is nothing', 'You carefully go over')
    pause 1
    text = reget(10)
    text.delete_if { |item| !item.include?('sturdy crate') }
    text.each_with_index do |crate, index|
      next unless crate =~ /from.* #{origin_town} and destined for/
      echo "FOUND AN EXPIRED CRATE AT #{$ORDINALS[index]}"
      dump_crate($ORDINALS[index])
      return
    end
  end

  def give_clerk
    clerk_id = find_closest_id('shipment_clerk')
    walk_to(clerk_id)
    bput('get my contract', 'You get', 'You are already holding that')
    Flags.add('caravan-upgrade', /Unfortunately, this load would kill/)
    bput('give my contract to clerk', /The .* clerk accepts your contract and peruses it\./)
    get_caravan if Flags['caravan-upgrade']
    bput("put my contract in my #{@contract_container}", 'You put')
    Flags.delete('caravan-upgrade')
  end

  def deposit_coins(withdraw_amt)
    return if wealth(@settings.hometown) < withdraw_amt
    near_town = closest_town

    return unless @bank_towns.include?(near_town)
    return unless @trading_towns[near_town]['deposit']
    return unless time_to_room(Room.current.id, @trading_towns[near_town]['deposit']['id']) < 20.0

    walk_to(@town_data[near_town]['deposit']['id'])
    case bput('deposit all', 'you drop all your', 'You hand the clerk some coins', "You don't have any", 'There is no teller here', 'reached the maximum balance I can permit')
    when 'There is no teller here'
      return
    end
  end

  def withdraw_coins(withdraw_amt)
    return unless wealth(@settings.hometown) < withdraw_amt
    near_town = closest_town
    return unless @bank_towns.include?(near_town)
    return unless @trading_towns[near_town]['deposit']
    return unless time_to_room(Room.current.id, @trading_towns[near_town]['deposit']['id']) < 20.0

    walk_to(@town_data[near_town]['deposit']['id'])
    minimize_coins(withdraw_amt).each { |amount| withdraw_exact_amount?(amount, @settings, "#{near_town}") }
  end

  def debugging?
    UserVars.trade_debug
  end

  ### TRAINING SECTION ###

  def attunement_routine
    return unless @training_token == 'Attunement'
    return unless @caravan_being_led || @step_toggle > 1
    bput('perc mana', 'You reach out')
    @step_toggle = 0
    wipe_token
    waitrt?
  end

  def appraisal_routine
    return unless @training_token == 'Appraisal'
    return unless @caravan_being_led || @step_toggle > 1
    be_inside_caravan
    case @appraisal_queue.first
    when 'instrument'
      @appraisal_queue = @appraisal_queue.rotate
      return appraisal_routine unless assess_instrument?
    when 'bundle'
      @appraisal_queue = @appraisal_queue.rotate
      return appraisal_routine unless appraise_bundle?
    when 'pouch'
      @appraisal_queue = @appraisal_queue.rotate
      return appraisal_routine unless appraise_worn_pouch?
    when 'full-pouch'
      unless appraise_held_pouch?
        @appraisal_queue = @appraisal_queue.rotate
        return appraisal_routine
      end
    end
    @step_toggle = 0
    wipe_token
    @cooldown_timers['Appraisal'] = Time.now
  end

  def appraise_worn_pouch?
    case bput("appraise my #{@gem_pouch_adjective} pouch", 'Roundtime', 'You can.t appraise the', 'Appraise what')
    when 'You can.t appraise the', 'Appraise what'
      @appraisal_queue -= ['pouch']
      false
    end
    true
  end

  def appraise_held_pouch?
    @pouch_ordinal ||= 0
    @pouch_ordinal = 0 if @pouch_ordinal > 10
    case bput("get #{$ORDINALS[@pouch_ordinal]} pouch from my #{@full_pouch_container}", '^You get ', '^What were you referring')
    when /^You get /
      bput('appraise my pouch', 'Roundtime')
      waitrt?
      bput("put my pouch in my #{@full_pouch_container}", 'You put')
      @pouch_ordinal += 1
      true
    else
      @appraisal_queue -= ['full-pouch'] if @pouch_ordinal.zero?
      @pouch_ordinal = 0
      false
    end
  end

  def appraise_bundle?
    case bput('appraise my bundle', 'Roundtime', 'Appraise what', 'You cannot appraise')
    when 'Appraise what', 'You cannot appraise'
      @appraisal_queue -= ['bundle']
      return false
    end
    waitrt?
    true
  end

  def assess_instrument?
    if DRSkill.getrank('Appraisal') >= 250
      @appraisal_queue -= ['instrument']
      return false
    end

    case bput("remove my #{@worn_instrument}", 'You slide', 'You remove', 'Remove what')
    when 'Remove what'
      @appraisal_queue -= ['instrument']
      return false
    end
    bput("assess my #{@worn_instrument}", 'you carefully look (them|it) over')
    waitrt?
    bput("wear my #{@worn_instrument}", 'You slide', 'You remove', 'You attach')
    true
  end

  def wipe_token
    echo "wiping @training_token #{@training_token}" if debugging?
    @training_token = nil
  end

  def is_playing?
    Script.running?('performance')
  end

  def magic_routine
    return if @training_spells.empty?
    return unless %w[Augmentation Warding Utility Outdoorsmanship Perception].include?(@training_token)
    return unless DRStats.concentration > 80
    DRCA.crafting_magic_routine(@settings)
    wipe_token if %w[Augmentation Warding Utility].include?(@training_token) && XMLData.prepared_spell.eql?('None')
  end

  def lead_training # Training that is done while being led or riding a caravan. Can have much longer RTs than in walk_training
    training_skills = @lead_training_skills
    check_training_token
    forage_grass
    @training_token ||= select_ability(training_skills)
    attunement_routine
    locksmithing_routine
    outdoorsmanship_routine
    performance_routine
    appraisal_routine
    first_aid_routine
    athletics_routine
    outfitting_routine
    engineering_routine
  end

  def training_cleanup # all training shuts down immediately upon arrival. Any routine that needs sanitizing goes here.
    outfitting_cleanup
    engineering_cleanup
    first_aid_cleanup
    performance_cleanup
    locksmithing_cleanup
    athletics_cleanup
    @step_toggle = -1
    wipe_token
    magic_cleanup
  end

  def walk_training
    training_skills = @walk_training_skills
    check_training_token
    forage_grass
    @training_token ||= select_ability(training_skills)
    attunement_routine
    appraisal_routine
    magic_routine
    performance_routine
  end

  def check_training_token
    return unless @training_token
    @cooldown_timers[@training_token] ||= Time.now
    return unless Time.now - @cooldown_timers[@training_token] > 5
    if DRSkill.getxp(@training_token) > 30 || Time.now - @cooldown_timers[@training_token] > 240
      training_cleanup
      @cooldown_timers[@training_token] = Time.now
    end
    if @training_token == 'First Aid' && !Script.running?('first-aid') && Time.now - @cooldown_timers['first-aid-run'] < 60
      # First-aid started up, ran through the compendium without hitting much RT, and it's time to stop.
      training_cleanup
      @cooldown_timers[@training_token] = Time.now
    end
    if @training_token == 'Athletics' && !Script.running?('athletics') && Time.now - @cooldown_timers['Athletics'] < 50
      training_cleanup
      DRC.message('Your dancing rope is tired!')
      wipe_skill('Athletics', @lead_training_skills)
      @cooldown_timers[@training_token] = Time.now
    end
  end

  def select_ability(training_skills) # selects a skill from the pool and returns it for @training_token - each skill routine can know what tokens it's compatible with.
    ability = next_to_train(training_skills)

    echo("Selected: #{ability}") if ability && debugging?
    @cooldown_timers[ability] = Time.now
    ability
  end

  def next_to_train(skill_list)
    skill_list.sort_by { |skill, _cooldown| DRSkill.getxp(skill) }
              .find { |skill, cooldown| check_ability?(skill, cooldown) }.first
  end

  def check_ability?(skill, cooldown) # stolen from combat-trainer. Skill cooldowns and other timing related data stored in @cooldown_timers
    expcheck = DRSkill.getxp(skill) < 25

    return expcheck unless @cooldown_timers[skill]
    Time.now - @cooldown_timers[skill] >= cooldown ? expcheck : false
  end

  # runs training boxes
  def locksmithing_routine
    return unless @training_token == 'Locksmithing'
    return locksmithing_cleanup if Flags['lockbox-done']
    return if Script.running?('lockbox')
    be_outside_caravan # can't pick inside a caravan because reasons

    if @box
      Flags.add('lockbox-done', 'The lock feels warm')
      start_script('lockbox')
    else
      echo '***UNABLE TO TRAIN LOCKSMITHING, REMOVING IT FROM THE TRAINING LIST***'
      locksmithing_cleanup
      wipe_skill('Locksmithing', @lead_training_skills)
      return
    end
  end

  def loot(box) # stolen from pick
    waitrt?
    if bput("open my #{box}", /^In the .* you see .*\./, 'That is already open', 'It is locked') == 'It is locked'
      return
    end
    raw_contents = bput("look in my #{box}", /^In the .* you see .*\./, 'There is nothing in there')
    return if raw_contents == 'There is nothing in there'

    loot = list_to_nouns(raw_contents.match(/^In the .* you see (.*)\./).to_a[1])
    loot.each { |item| loot_item(item, box) }
  end

  def loot_item(item, box) # stolen from pick
    return if item =~ /fragment/i
    message = bput("get #{item} from my #{box}", 'You get .* from inside', 'You pick up')
    return if message == 'You pick up'
    message =~ /You get (.*) from inside/
    item_long = Regexp.last_match(1)
    special = @settings.loot_specials.find { |x| /\b#{x['name']}\b/i =~ item_long }
    if special
      bput("put #{item} in my #{special['bag']}", 'you put')
      return
    end
    if @loot_nouns.find { |thing| item_long.include?(thing) && !item_long.include?('sunstone runestone') }
      message = bput("stow my #{item}", 'You put', 'You open', 'You think the .* pouch is too full to fit', 'You\'d better tie it up before putting')
      return if ['You put', 'You open'].include?(message)
      fput("drop #{item}")
      return unless @settings.spare_gem_pouch_container
      bput("remove my #{@gem_pouch_adjective} pouch", 'You remove')
      if @full_pouch_container
        bput("put my #{@gem_pouch_adjective} pouch in my #{@full_pouch_container}", 'You put')
      else
        bput("stow my #{@gem_pouch_adjective} pouch", 'You put')
      end
      bput("get #{@gem_pouch_adjective} pouch from my #{@settings.spare_gem_pouch_container}", 'You get a')
      bput('wear my pouch', 'You attach')
      bput("stow #{item}", 'You pick')
      if message =~ /tie it up/
        fput('close my pouch')
      else
        bput('tie my pouch', 'You tie')
      end
    elsif @trash_nouns.find { |thing| item_long =~ /\b#{thing}\b/i }
      dispose_trash(item)
    else
      beep
      echo('***Unrecognized Item! trashing it.***')
      dispose_trash(item)
    end
  end

  def locksmithing_cleanup # sanitizes locksmithing_routine
    return unless @training_token == 'Locksmithing'
    wipe_token
    stop_script('lockbox') if Script.running?('lockbox')
    pause 1
    stop_script('pick') if Script.running?('pick')
    waitrt?
    if @box && @worn_lockbox && DRCI.in_hands?(@box)
      bput("pick my #{@box}", 'not making any progress', 'it opens.', "isn't locked", 'The lock feels warm', 'But you aren\'t')
      bput("open my #{@box}", 'You open', 'It is locked')
      bput("wear my #{@box}", 'You put', 'You sling', 'You are already')
    else
      @equipment_manager.empty_hands
    end
    stow_hands
    @box = nil if Flags['lockbox-done']
    Flags.delete('lockbox-done')
  end

  def outdoorsmanship_routine # steps outside and collects rocks
    return if is_playing? || !%w[Outdoorsmanship Perception].include?(@training_token)
    be_outside_caravan
    collect('rock')
    waitrt?
    wipe_token
  end

  def get_grass
    case bput('get my grass from my feedbag', 'You get', 'What were you')
    when 'What were you'
      bput('get my grass from my feedbag', 'You get', 'What were you')
    end
    @current_grass_count -= 1
  end

  def empty_trash
    trash_nouns = get_data('items').trash_nouns

    if trash_nouns.any? { |noun| /\b#{noun}/i =~ GameObj.right_hand.noun } && !@equipment_manager.is_listed_item?(right_hand)
      dispose_trash(right_hand)
    end

    if trash_nouns.any? { |noun| /\b#{noun}/i =~ GameObj.left_hand.noun } && !@equipment_manager.is_listed_item?(left_hand)
      dispose_trash(left_hand)
    end
  end

  def wipe_skill(skill_name, training_skills) # removes a skill by name from the list of trainables (out of materials/boxes, for example)
    return unless training_skills.include?(skill_name)
    echo "Wiping skill #{skill_name} from training"
    training_skills.reject! { |skill, _cooldown| skill == skill_name }
  end

  def restore_skill(skill_name, cooldown, training_skills) # restores a skill wiped from trainables (restocked materials, for example)
    echo "Restoring skill #{skill_name} to training"
    skill_hash = { skill_name => cooldown }
    training_skills.merge!(skill_hash)
  end

  def sorcery_routine
    # NOT YET IMPLEMENTED - ONLY PERFORM IN CARAVAN INTERIOR
  end

  def count_materials(material) # Gets a count of crafting mats.
    result = DRC.bput("count my #{material}", 'I could not', 'You count out \d+', 'The straight pins has \d+ use')

    stow_hands
    @current_materials[material] = result.scan(/\d+/).first.to_i
  end

  def buy_wood(skipcoin = false)
    return unless @caravan_training_skills.include?('Engineering')
    town = closest_town
    return unless @crafting_data['shaping'][town]
    return unless @current_materials['balsa lumber'] < @lumber_quantity
    return unless time_to_room(Room.current.id, @crafting_data['shaping'][town]['stock-room']) < 20.0
    be_outside_caravan
    crafting_data = get_data('crafting')
    stow_hands
    shift_hometown(town)
    ensure_copper_on_hand(3000, @settings) unless skipcoin
    walk_to(crafting_data['shaping'][town]['stock-room'])
    bput('get my balsa lumber', 'You get', 'You are already', 'What were you')
    DRCT.order_item(crafting_data['shaping'][town]['stock-room'], 11)
    bput('combine', 'combine')
    count_materials('balsa lumber')
    buy_wood(true) if @current_materials['balsa lumber'] < @lumber_quantity
    stow_hands
    clear_hometown
  end

  def buy_outfitting_mats
    return unless @caravan_training_skills.include?('Outfitting')
    town = closest_town
    return unless @crafting_data['tailoring'][town]
    return unless time_to_room(Room.current.id, @crafting_data['shaping'][town]['stock-room']) < 20.0
    be_outside_caravan
    shift_hometown(town)
    crafting_data = get_data('crafting')['tailoring'][town]
    stow_hands
    ensure_copper_on_hand(5000, @settings)

    should_knit? ? buy_yarn(crafting_data) : buy_cloth(crafting_data)
    clear_hometown
  end

  def should_knit?
    @crafting_override['tailoring']['recipe'].include?('knitted') || DRSkill.getrank('Outfitting') < 550
  end

  def buy_yarn(crafting_data)
    return unless @current_materials[@outfitting_material_type] < @outfitting_quantity
    walk_to(crafting_data['stock-room'])
    bput('get my wool yarn', 'You get', 'You are already', 'What were you')
    DRCT.order_item(crafting_data['stock-room'], 13)
    bput('combine my yarn', 'You combine', 'You must be holding both')
    count_materials('wool yarn')
    buy_yarn(crafting_data) if @current_materials[@outfitting_material_type] < @outfitting_quantity
    stow_hands
  end

  def buy_cloth(crafting_data)
    count_materials('burlap cloth')
    if @current_materials[@outfitting_material_type] < @outfitting_quantity
      existing = if bput("get burlap cloth from my #{@craft_bag}", 'What were', 'You get') == 'What were'
                  0
                else
                  while bput("get burlap cloth from my #{@craft_bag}", 'What were', 'You get') == 'You get'
                    bput('combine burlap cloth with burlap cloth', 'You combine')
                  end
                  count_materials('burlap cloth')
                end
      stock_needed = ((@outfitting_quantity - existing) / 10.0).ceil

      order_fabric(crafting_data['stock-room'], stock_needed, crafting_data['sew-stock-number'], "#{crafting_data['sew-stock-name']} cloth")
      count_materials('burlap cloth') if stock_needed > 0
    end

    check_thread(crafting_data)
    check_pins(crafting_data)

    stow_hands
  end

  def check_thread(crafting_data)
    return if count_materials('cotton thread') > 20
    ensure_copper_on_hand(1000, @settings)
    walk_to(crafting_data['stock-room'])
    get_item('cotton thread') if exists?('cotton thread')
    DRCT.order_item(crafting_data['stock-room'], 6)
    bput('combine', 'You combine', 'You must')
    DRCT.order_item(crafting_data['stock-room'], 6)
    bput('combine', 'You combine', 'You must')
    stow_item('cotton thread')
    count_materials('cotton thread')
  end

  def check_pins(crafting_data)
    return if count_materials('straight pins') > 20  # adjust
    ensure_copper_on_hand(1000, @settings)
    walk_to(crafting_data['tool-room'])
    get_item('straight pins') if exists?('straight pins')
    dispose_trash('straight pins')
    DRCT.order_item(crafting_data['tool-room'], 5)
    stow_item('straight pins')
  end

  def order_fabric(stock_room, stock_needed, stock_number, type)
    stock_needed.times do
      DRCT.order_item(stock_room, stock_number)
      bput("get my #{type} from my #{@craft_bag}", 'What were', 'You get')
      next unless left_hand && right_hand
      bput("combine #{type} with #{type}", 'You combine')
    end
    stow_item(type)
  end

  def get_item(item)
    get_crafting_item(item, @craft_bag, @craft_belt, @craft_belt, true)
  end

  def stow_item(item)
    stow_crafting_item(item, @craft_bag, @craft_belt)
  end

  def outfitting_routine
    return unless @training_token == 'Outfitting'
    return if Script.running?('sew')
    @craft_belt = @settings.outfitting_belt
    if @crafted_item && left_hand.include?(@crafted_item.split.last) || right_hand.include?(@crafted_item.split.last)
      dispose_item_caravan(@crafted_item.split.last)
    end

    if should_knit?
      result =  bput('look my knitting needles',
                   /The knitting needles are in the process of knitting (?:some|an?) unfinished knitted .+ (.+)\./,
                   'The knitting needles are not in the process', 'I could not find')
      if result =~ /The knitting needles are in the process of knitting (?:some|an?) unfinished knitted .+ (.+)\./
        @crafted_item = Regexp.last_match(1)
        echo "sewing found an item to resume: #{@crafted_item}"
        get_item('knitting needle')
        be_inside_caravan
        magic_cleanup
        start_script('sew', ['resume', @crafted_item])
        return
      end
    end

    rank = DRSkill.getrank('Outfitting')

    if @crafting_override['tailoring']
      @crafted_item = @crafting_override['tailoring']['recipe']
    elsif rank <= 25 # Tier 1  Extremely Easy
      @crafted_item = 'knitted socks'
    elsif rank <= 50 # Tier 2 Very Easy
      @crafted_item = 'knitted mittens'
    elsif rank <= 100 # Tier 3  Easy
      @crafted_item = 'knitted hat'
    elsif rank <= 175 # Tier 4  Simple
      @crafted_item = 'knitted gloves'
    elsif rank <= 300 # Tier 5  Basic
      @crafted_item = 'knitted hose'
    elsif rank <= 425 # Tier 6  Somewhat Challenging
      @crafted_item = 'knitted cloak'
    elsif rank <= 550 # Tier 7  Challenging
      @crafted_item = 'knitted blanket'
    elsif rank <= 620 # Tier 8
      @crafted_item = 'deeply-hooded cloak'
    elsif rank <= 750 # Tier 9
      @crafted_item = 'a cloth mage\'s robe'
    elsif rank <= 1050 # Tier 10
      @crafted_item = 'a cloth mining belt'
    elsif rank <= 1450 # Tier 11
      @crafted_item = 'a cloth survival belt'
    else # Tier 12
      @crafted_item = 'a cloth artisan\'s belt'
    end
    recipes = @recipe_data.crafting_recipes.select { |recipe| recipe['type'] =~ /tailoring/i }
                                                  .reject { |recipe| recipe['chapter'] == 7 }
    echo @crafted_item
    recipe = recipe_lookup(recipes, @crafted_item)

    if /unfinished/ =~ bput("tap my #{@crafted_item.split.last} in my #{@craft_bag}", 'You tap .*', 'I could not find')
      bput("get my #{@crafted_item.split.last} from my #{@craft_bag}", 'You get', 'What were', 'But that')
      pause 2 if Script.running?('bescort')
      if DRCI.in_hands?(@crafted_item.split.last)
        echo "sewing found item to resume: #{@crafted_item}"
        be_inside_caravan
        magic_cleanup
        start_script('sew', ['resume', @crafted_item.split.last])
        return
      end
    end

    pins = should_knit? ? 100 : count_materials('straight pins')
    thread = should_knit? ? 100 : count_materials('cotton thread')

    if recipe['volume'] > @current_materials[@outfitting_material_type] || pins < 10 || thread < 100
      wipe_skill('Outfitting', @lead_training_skills)
      return outfitting_cleanup
    else
      be_inside_caravan
      magic_cleanup
      outfitting_type = should_knit? ? 'knitting' : 'sewing'
      outfitting_mat = should_knit? ? 'wool' : 'burlap'
      @current_materials[@outfitting_material_type] -= recipe['volume']
      start_script('sew', ['stow', outfitting_type, recipe['chapter'], recipe['name'], recipe['noun'], outfitting_mat].map { |arg| arg =~ /\s/ ? "\"#{arg}\"" : arg })
    end
  end

  def outfitting_cleanup # sanitizes outfitting_routine
    return unless @training_token == 'Outfitting'
    stop_script('sew') if Script.running?('sew')
    if should_knit?
      stow_item('knitting needle')
    else
      stow_item(left_hand) if left_hand
      open_storage_box
      suffix = "in my #{@craft_bag}" unless DRCI.in_hands?(@crafted_item.split.last)
      case bput("tap my #{@crafted_item.split.last} #{suffix}", 'unfinished', "You tap .* #{@crafted_item.split.last}", 'I could not find')
      when /unfinished/
        get_item(@crafted_item.split.last) if suffix
        stow_item(@crafted_item.split.last)
      when /You tap/
        dispose_item_caravan(@crafted_item.split.last)
      end
      bput("get my #{@outfitting_material_type}", 'You get', 'You pick up', 'You are already', 'What were you')
      stow_item(@outfitting_material_type)
    end
    be_outside_caravan
    if @crafted_item && DRCI.in_hands?(@crafted_item.split.last)
      dispose_item_caravan(@crafted_item.split.last)
    end
    magic_cleanup
    stow_hands
    wipe_token
    @times_outfitting += 1
  end

  def engineering_routine # shapes.  Will stow unfinished projects, and search your storage_containers for them later.
    return unless @training_token == 'Engineering'
    return if Script.running?('shape')
    @craft_belt = @settings.engineering_belt
    rank = DRSkill.getrank('Engineering')
    if @crafting_override['shaping']
      @crafted_item = @crafting_override['shaping']['recipe']
    elsif rank <= 25 # Tier 1  Extremely Easy
      @crafted_item = 'wood band'
    elsif rank <= 50 # Tier 2 Very Easy
      @crafted_item = 'a wood bracelet'
    elsif rank <= 80 # Tier 3  Easy
      @crafted_item = 'a wood cloak pin'
    elsif rank <= 140 # Tier 4  Simple
      @crafted_item = 'wood amulet'
    elsif rank <= 255 # Tier 5  Basic
      @crafted_item = 'wood brooch'
    elsif rank <= 380 # Tier 6  Somewhat Challenging
      @crafted_item = 'wood armband'
    elsif rank <= 535 # Tier 7  Challenging
      @crafted_item = 'wood choker'
    elsif rank <= 640 # Tier 8 - Complicated
      @crafted_item = 'articulated wood necklace'
    elsif rank <= 765 # Tier 9 - Intricate
      @crafted_item = 'wood crown'
    elsif rank <= 1050 # Tier 10 - Difficult
      @crafted_item = 'wood comb'
    elsif rank <= 1400 # Tier 11 - Very Difficult
      @crafted_item = 'wood haircomb'
    else # Tier 12  Extremely Difficult
      echo('*** NOT YET IMPLEMENTED ***')
      wipe_skill('Engineering', @lead_training_skills)
      return engineering_cleanup
    end

    if left_hand.include?(@crafted_item.split.last) || right_hand.include?(@crafted_item.split.last)
      if /unfinished/ =~ bput("tap my #{@crafted_item.split.last}", 'unfinished', "You tap .* #{@crafted_item.split.last}", 'I could not find')
        stow_item(@crafted_item.split.last)
      else
        dispose_item_caravan(@crafted_item.split.last)
      end
    end

    if /unfinished/ =~ bput("tap my #{@crafted_item.split.last} in my #{@craft_bag}", 'unfinished', 'You tap .*', 'I could not find')
      bput("get my #{@crafted_item.split.last} from my #{@craft_bag}", 'You get', 'What were', 'But that')
      pause 2 if Script.running?('bescort')
      if DRCI.in_hands?(@crafted_item.split.last)
        echo "Engineering found an uncompleted item #{@crafted_item}"
        be_inside_caravan
        magic_cleanup
        start_script('shape', ['continue', @crafted_item.split.last])
        return
      end
    end

    recipes = @recipe_data.crafting_recipes.select { |recipe| recipe['type'] =~ /shaping/i }
    recipe = recipe_lookup(recipes, @crafted_item)
    if recipe['volume'] > @current_materials['balsa lumber']
      wipe_skill('Engineering', @lead_training_skills)
      return engineering_cleanup
    else
      be_inside_caravan
      magic_cleanup
      @current_materials['balsa lumber'] -= recipe['volume']
      echo "recipe is #{recipe}" if debugging?
      start_script('shape', ['stow', recipe['chapter'], recipe['name'], 'balsa', recipe['noun']].map { |arg| arg =~ /\s/ ? "\"#{arg}\"" : arg })
    end
  end

  def engineering_cleanup # sanitizes engineering
    return unless @training_token == 'Engineering'
    stop_script('shape') if Script.running?('shape')
    pause 1
    stow_item(right_hand) if right_hand
    suffix = "in my #{@craft_bag}" unless DRCI.in_hands?(@crafted_item.split.last)
    case bput("tap my #{@crafted_item.split.last} #{suffix}", 'unfinished', "You tap .* #{@crafted_item.split.last}", 'I could not find')
    when /unfinished/
      get_item(@crafted_item.split.last) if suffix
      stow_item(@crafted_item.split.last)
    when /You tap/
      dispose_item_caravan(@crafted_item.split.last)
    end
    stow_hands
    bput('get my balsa lumber', 'You get', 'You pick up', 'You are already', 'What were you')
    stow_item('balsa lumber')
    be_outside_caravan
    wipe_token
    magic_cleanup
    @times_engineering += 1
  end

  def first_aid_routine # runs ;first-aid on compendiums or textbooks
    return unless @training_token == 'First Aid'
    return if Script.running?('first-aid')
    check_training_token
    be_inside_caravan
    @cooldown_timers['first-aid-run'] = Time.now
    start_script('first-aid')
  end

  def first_aid_cleanup
    return unless @training_token == 'First Aid'
    wipe_token
    stop_script('first-aid') if Script.running?('first-aid')
    waitrt?
    @cooldown_timers['first-aid-run'] = Time.now
    pause 1 while Script.running?('first-aid') || Script.running?('performance')
    stow_hands
  end

  def athletics_routine
    return unless @training_token == 'Athletics'
    return if Script.running?('athletics')
    be_inside_caravan
    start_script('athletics', ['stationary'])
  end

  def athletics_cleanup
    return unless @training_token == 'Athletics'
    wipe_token
    stop_script('athletics') if Script.running?('athletics')
    waitrt?
    pause 1 while Script.running?('athletics')
    DRC.stop_playing
    bput('stop climb', 'You stop practicing your climbing skills.', "You weren't practicing your climbing skills anyway.")
    stow_hands
    DRC.fix_standing
  end

  def performance_routine # runs ;performance.  Will run ;first-aid too, if it hasn't been done very recently.
    return unless @training_token == 'Performance'
    if @lead_training_skills.include?('First Aid') && @caravan_being_led && check_ability?('First Aid', 180)
      @training_token = 'First Aid'
      @cooldown_timers['First Aid'] = Time.now
      return
    end

    return if is_playing?
    magic_cleanup
    be_inside_caravan if @caravan_being_led
    start_script('performance')
  end

  def performance_cleanup
    return unless @training_token == 'Performance'
    wipe_token
    bput("wear my #{@worn_instrument}", 'You slide', 'You attach') if left_hand.include?(@worn_instrument) || right_hand.include?(@worn_instrument)
    stow_hands
    stop_script('performance') if is_playing?
    pause 1 while Script.running?('performance')
    waitrt?
  end

  def check_wounds
    room = Room.current.id
    shift_hometown(closest_town)
    wait_for_script_to_complete('safe-room')
    clear_hometown
    walk_to(room)
  end

  def town_business # run every time it delivers/picks up a contract from Crossing/another hub. Replenishes resources and stocks coins
    echo "Town business" if debugging?
    count_materials(@outfitting_material_type) if @caravan_training_skills.include?('Outfitting')
    count_materials('balsa lumber') if @caravan_training_skills.include?('Engineering')
    return if time_to_room(Room.current.id, find_closest_id('trader_outpost')) > 5.0
    save_caravan_position(Room.current.id)
    command_caravan?('wait')
    turn_in_items
    deposit_coins(@caravan_coins_on_hand)
    withdraw_coins(@caravan_coins_on_hand)
    check_forging
    repair_tools
    check_hunting
    return_to_caravan
    buy_outfitting_mats
    buy_wood
    restocked_restore
    return_to_caravan
    count_grass
  end

  def check_forging
    return unless @caravan_training_skills.include?('Forging')
    return unless @crafting_data['blacksmithing'][closest_town]
    return unless DRSkill.getxp('Forging') < 14
    @cooldown_timers['Forging'] ||= Time.now
    return if time_to_room(Room.current.id, @crafting_data['blacksmithing'][closest_town]['stock-room']) > 20.0
    return unless check_ability?('Forging', @caravan_training_skills['Forging'])
    DRC.message('Going Forging!')
    shift_hometown(closest_town) # Dependency function
    wait_for_script_to_complete('workorders', ['blacksmithing'])
    @cooldown_timers['Forging'] = Time.now
    clear_hometown # Dependency function
  end

  def check_hunting
    return unless @hunt
    @cooldown_timers['Hunting'] ||= Time.now - 600
    return unless closest_town == @settings.hometown # right now it only runs hunt when you reach your hometown
    return unless DRSkill.getxp('Trading') > 12
    return unless Time.now - @cooldown_timers['Hunting'] >= 1200
    return_to_caravan
    DRC.message('Going Hunting!')
    store_item_in_box('balsa lumber') if @caravan_training_skills.include?('Engineering') && DRCI.exists?('balsa lumber')
    store_item_in_box(@outfitting_material_type) if @caravan_training_skills.include?('Outfitting') && DRCI.exists?(@outfitting_material_type)
    wait_for_script_to_complete('hunting-buddy', ['caravanhunt'])
    wait_for_script_to_complete('safe-room')
    stow_hands
    return_to_caravan
    get_item_from_storage_box?('balsa lumber') if @caravan_training_skills.include?('Engineering') && get_storage_inventory.include?('lumber')
    get_item_from_storage_box?(@outfitting_material_type) if @caravan_training_skills.include?('Outfitting') && get_storage_inventory.include?('cloth')
    @cooldown_timers['Hunting'] = Time.now
  end

  def sell_loot
    return unless closest_town == @settings.hometown
    wait_for_script_to_complete('sell-loot')
  end

  def repair_tools
    room = Room.current.id
    if @caravan_training_skills.include?('Outfitting') && @times_outfitting > 6 && @crafting_data['tailoring'][closest_town] && time_to_room(Room.current.id, @crafting_data['tailoring'][closest_town]['stock-room']) < 20.0
      shift_hometown(closest_town)
      wait_for_script_to_complete('workorders', %w[tailoring repair])
      clear_hometown
      @times_outfitting = 0
    end
    if @caravan_training_skills.include?('Engineering') && @times_engineering > 6 && @crafting_data['shaping'][closest_town] && time_to_room(Room.current.id, @crafting_data['shaping'][closest_town]['stock-room']) < 20.0
      shift_hometown(closest_town)
      wait_for_script_to_complete('workorders', %w[shaping repair])
      clear_hometown
      @times_engineering = 0
    end
    walk_to(room)
  end

  def turn_in_items
    return if @crafting_override.empty?
    return unless @use_storage_box
    return_to_caravan
    inventory = get_storage_inventory
    town = closest_town
    @crafting_override.select { |_discipline, data| inventory.group_by(&:itself)[data['recipe'].split.last].length > 4 }
                      .select { |discipline, _data| @crafting_data[discipline][town] && time_to_room(Room.current.id, @crafting_data[discipline][town]['stock-room']) < 10.0 }
                      .select { |_discipline, data| data['workorder'] }
                      .each do  |discipline, data|

      info = @crafting_data[discipline][town]
      recipes = @recipe_data.crafting_recipes.select { |recipe| recipe['type'] =~ /#{discipline}/i && /#{@crafting_override[discipline]['recipe']}/ =~ recipe['name'] }
      echo recipes
      item_name, quantity = request_work_order(recipes, info['npc-rooms'], info['npc'], info['npc_last_name'], discipline, info['logbook'], data['difficulty'])
      if item_name.nil?
        @crafting_override[discipline]['workorder'] = false
        DRC.message('Could not find a workorder for the item')
        return turn_in_items
      end

      return_to_caravan
      quantity.times do
        return unless get_item_from_storage_box?(data['recipe'].split.last)
        DRCC.logbook_item(info['logbook'], data['recipe'].split.last, @craft_bag)
      end
      complete_work_order(info)
      return turn_in_items
    end
  end

  def complete_work_order(info)
    stow_hands
    loop do
      find_npc(info['npc-rooms'], info['npc_last_name'])
      bput("get my #{info['logbook']} logbook", 'You get', 'You are already', 'What is it')
      DRC.release_invisibility
      result = bput("give log to #{info['npc']}", 'You hand', 'You can', 'What were you', 'Apparently the work order time limit has expired', 'The work order isn\'t yet complete')
      break unless ['What is it', 'What were you', 'You can'].include?(result)
    end
    stow_item('logbook')
  end

  def request_work_order(recipes, npc_rooms, npc, npc_last_name, discipline, logbook, diff)
    match_names = recipes.map { |x| x['name'] }
    echo match_names
    diff ||= 'challenging'
    stow_hands
    75.times do
      find_npc(npc_rooms, npc_last_name)
      bput("get my #{logbook} logbook", 'You get') unless left_hand || right_hand
      result = bput("ask #{npc} for #{diff} #{discipline} work", '^To whom', 'order for .* I need \d+ .*', 'order for .* I need \d+ stacks \(5 uses each\) of .* quality', 'You realize you have items bundled with the logbook', 'You want to ask about shadowlings')
      case result
      when 'You want to ask about shadowlings'
        pause 10
        fput('say Hmm.')
      when /order for (.*)\. I need (\d+) stacks \(5 uses each\) of .* quality/, /order for (.*)\. I need (\d+)/
        item = Regexp.last_match(1)
        quantity = Regexp.last_match(2).to_i
        if match_names.include?(item) && /leather/ !~ result
          stow_item('logbook')
          return [item, quantity]
        end
      when 'You realize you have items bundled with the logbook'
        bput('untie my logbook', 'You untie')
        if left_hand.include?('logbook')
          fput("drop my #{right_hand}")
        else
          fput("drop my #{left_hand}")
        end
        get_item('logbook') unless DRCI.in_hands?('logbook')
      end
    end
    stow_item('logbook')
    [nil, nil]
  end

  def find_npc(room_list, npc)
    room_list.each do |room_id|
      break if DRRoom.npcs.include?(npc)
      walk_to(room_id)
    end
  end

  def restocked_restore # restore material-limited skills once bought by town_business
    restore_skill('Outfitting', @caravan_training_skills['Outfitting'], @lead_training_skills) if @current_materials[@outfitting_material_type] > 10 && @current_materials['straight pins'] >= 20 && @current_materials['wool thread'] >= 100 && @caravan_training_skills.include?('Outfitting') && !@lead_training_skills.include?('Outfitting')
    restore_skill('Engineering', @caravan_training_skills['Engineering'], @lead_training_skills) if @current_materials['balsa lumber'] > 5 && @caravan_training_skills.include?('Engineering') && !@lead_training_skills.include?('Engineering')
  end

  def magic_cleanup
    return if @training_spells.empty?
    bput('release symbiosis', "But you haven't", 'You release', 'Repeat this command')
    bput('release spell', 'You let your concentration lapse', "You aren't preparing a spell") unless checkprep == 'None'
    bput('release mana', 'You release all', "You aren't harnessing any mana")
  end

  def discard_item(item)
    # buckets on caravan to be added
    DRCI.dispose_trash(item)
  end

  def dispose_item_caravan(item)
    if @use_storage_box
      store_item_in_box(item)
    else
      bput("drop my #{item}", 'You drop', 'You place', 'What were', 'You spread')
    end
  end

  def empty_storage_box
    return unless @use_storage_box
    be_outside_caravan
    inventory = get_storage_inventory
    return if inventory.empty?
    inventory.each do |item|
      get_item_from_storage_box?(item)
      discard_item(item)
    end
    empty_storage_box
  end

  def get_storage_inventory
    return unless @use_storage_box
    be_outside_caravan
    open_storage_box
    result = DRC.bput("rummage in storage box on #{@caravan.adjective} #{@caravan.noun}", '^You rummage through a storage box but', 'You rummage through a storage box and see .*', 'While it\'s closed', 'I don\'t know what you are referring to', 'You feel about')

    case result
    when 'You feel about'
      release_invisibility
      return get_storage_inventory
    when /You rummage through a storage box but/
      return []
    when /I don\'t know what you are referring to/
      pause 1
      return get_storage_inventory
    when /While it\'s closed/
      open_storage_box
      return get_storage_inventory
    end

    text = result.match(/and see (.*)\.$/).to_a[1]
    list_to_nouns(text)
  end

  def open_storage_box
    return unless @use_storage_box
    be_outside_caravan
    case bput("open box on #{@caravan.adjective} #{@caravan.noun}", '^You open', '^That is already open', '^What were you', '^You need a free hand')
    when /You need a free hand/
      lefty = DRC.left_hand
      bput("put my #{lefty} in my #{@craft_bag}", '^You put')
      open_storage_box
      get_item(lefty)
    when /What were you/
      wait_for_caravan(1)
      open_storage_box
    end
  end

  def store_item_in_box(item)
    return unless @use_storage_box
    be_outside_caravan
    result = bput("get my #{item}", '^You get', '^What were you', '^You are already') unless DRC.right_hand =~ /#{item}/ || DRC.left_hand =~ /#{item}/
    return if /What were you/ =~ result
    case bput("put my #{item} in box on #{@caravan.adjective} #{@caravan.noun}", '^You put', '^But that is closed', '^What were you')
    when /But that is closed/
      open_storage_box
      store_item_in_box(item)
    when /What were you/
      wait_for_caravan(1)
      store_item_in_box(item)
    end
  end

  def get_item_from_storage_box?(item)
    return unless @use_storage_box
    be_outside_caravan
    wait_for_caravan(1)
    case bput("get #{item} from box on #{@caravan.adjective} #{@caravan.noun}", '^You get', '^You pick', '^But that is closed', '^What were you')
    when /But that is closed/
      open_storage_box
      get_item_from_storage_box?(item)
    when /What were you/
      if bput("look in box on #{@caravan.adjective} #{@caravan.noun}", 'In the storage box', 'That is closed', 'There is nothing') == 'That is closed'
        open_storage_box
        return get_item_from_storage_box?(item)
      else
        false
      end
    else
      true
    end
  end
end

before_dying do
  Flags.delete('caravan-arrived')
  Flags.delete('caravan-upgrade')
  Flags.delete('lead-arrived')
  Flags.delete('lead-failed')
  Flags.delete('lockbox-done')
  Flags.delete('trade-gondola-arrive')
  Flags.delete('trade-barge')
  Flags.delete('trade-bescort')
  Script.unpause('skill-recorder') if Script.paused?('skill-recorder')
  # THEREN ROPE BRIDGE
  Room[8637].timeto['8650'] = 180.0 unless Room[8637].timeto['8650']
  Room[8650].timeto['8637'] = 180.0 unless Room[8650].timeto['8637']
  # AIRSHIP
  Room[989].timeto['247'] = 600.0 unless Room[989].timeto['247']
  Room[247].timeto['989'] = 600.0 unless Room[247].timeto['989']
  Room[3766].timeto['6872'] = 799.0
  Room[6872].timeto['6872'] = 799.0
  clear_hometown
end

Trade.new.run
